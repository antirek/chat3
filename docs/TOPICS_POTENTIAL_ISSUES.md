# Потенциальные проблемы реализации топиков

## 1. Валидация и целостность данных

### 1.1. Валидация topicId при создании сообщения
**Проблема:** При создании сообщения с `topicId` нет проверки:
- Существует ли топик с указанным `topicId`
- Принадлежит ли топик указанному диалогу
- Не был ли топик удален (если в будущем добавится удаление)

**Риск:** Сообщения могут быть созданы с несуществующим или неверным `topicId`, что приведет к:
- Ошибкам при получении информации о топике (`getTopicWithMeta()` вернет `null`)
- Некорректным счетчикам в `UserTopicStats`
- Проблемам с фильтрацией сообщений

**Решение:** Добавить валидацию в `messageController.create`:
- Проверять существование топика через `getTopicById()` перед созданием сообщения
- Если `topicId` указан, но топик не найден - вернуть ошибку 404:
  ```json
  {
    "error": "ERROR_NO_TOPIC",
    "message": "Topic not found"
  }
  ```

### 1.2. Ссылочная целостность при удалении топика
**Проблема:** ~~Если в будущем добавится удаление топиков, что делать с сообщениями, у которых `topicId` указывает на удаленный топик?~~

**Решение:** ✅ **Удаление топиков запрещено** - это решает проблему ссылочной целостности. Топики нельзя удалять, что защищает от:
- Потери данных (сообщения всегда имеют валидный `topicId`)
- "Висячих" ссылок в сообщениях
- Рассинхронизации счетчиков в `UserTopicStats`
- Нарушения правила "нельзя перемещать сообщения"

### 1.3. Проверка принадлежности топика к диалогу
**Проблема:** При создании сообщения с `topicId` нужно убедиться, что топик принадлежит указанному диалогу.

**Риск:** Можно случайно указать `topicId` из другого диалога (хотя это маловероятно из-за уникальности `topicId`).

**Решение:** В `getTopicById()` уже есть проверка `dialogId`, но нужно убедиться, что она используется при валидации.

## 2. Синхронизация счетчиков

### 2.1. Рассинхронизация UserDialogStats и UserTopicStats
**Проблема:** Общий `unreadCount` в `UserDialogStats` должен равняться сумме всех `unreadCount` из `UserTopicStats` для диалога. Но:
- Если обновление `UserTopicStats` прошло, а обновление `UserDialogStats` упало - счетчики рассинхронизируются
- Если событие обработалось дважды (retry) - счетчики могут быть завышены
- Если событие не обработалось - счетчики могут быть занижены

**Риск:** Некорректные данные о непрочитанных сообщениях для пользователя.

**Решение:** ✅ Использовать транзакции MongoDB для атомарного обновления обоих счетчиков:
- При создании сообщения использовать транзакцию для атомарного обновления `UserTopicStats` и `UserDialogStats`
- При изменении статуса сообщения на `read` использовать транзакцию для атомарного обновления счетчиков
- Если обновление счетчиков упадет, операция не должна быть выполнена (откат транзакции)
- Добавить функцию `recalculateDialogUnreadCount()` для восстановления консистентности (на случай рассинхронизации)
- Идемпотентные операции `$inc` защищают от дублирования при повторной обработке событий

### 2.2. Обновление DialogStats при ошибках
**Проблема:** `DialogStats` обновляется в `update-worker` при обработке событий. Если событие обработалось, но обновление `DialogStats` упало - счетчик будет неверным.

**Риск:** Некорректная статистика диалога (`topicCount`, `memberCount`, `messageCount`).

**Решение:**
- Использовать идемпотентные операции (`$inc` уже идемпотентен)
- Добавить функцию пересчета `DialogStats` из реальных данных:
  - `topicCount` = `Topic.countDocuments({ tenantId, dialogId })`
  - `memberCount` = `DialogMember.countDocuments({ tenantId, dialogId })`
  - `messageCount` = `Message.countDocuments({ tenantId, dialogId })`

### 2.3. Двойное обновление счетчиков
**Проблема:** При создании сообщения:
- В контроллере обновляется `UserTopicStats` и `UserDialogStats`
- В `update-worker` обновляется `DialogStats.messageCount`
- Но если событие `message.create` обработается дважды - `DialogStats.messageCount` увеличится дважды

**Риск:** Завышенные счетчики в `DialogStats`.

**Решение:** ✅ Использовать идемпотентные операции (`$inc` в MongoDB) - все операции обновления счетчиков должны использовать `$inc` для атомарного идемпотентного обновления. Это гарантирует, что повторная обработка события не приведет к дублированию изменений.

## 3. Производительность

### 3.1. N+1 проблема при получении topic для сообщений
**Проблема:** При получении списка сообщений для каждого сообщения вызывается `getTopicWithMeta()`, что приводит к множественным запросам к БД.

**Риск:** Медленная работа API при большом количестве сообщений.

**Решение:** ✅ Добавлена функция `getTopicsWithMetaBatch()` в `topicUtils.js`:
- Собрать все уникальные `topicId` из сообщений (исключить `null`)
- Загрузить все топики одним запросом: `Topic.find({ tenantId, dialogId, topicId: { $in: topicIds } })`
- Загрузить все мета-теги одним запросом: `Meta.find({ tenantId, entityType: 'topic', entityId: { $in: topicIds } })`
- Собрать map `topicId -> { topicId, meta }` и использовать для обогащения сообщений
- Все контроллеры сообщений (`messageController`, `userDialogController`) используют батчинг вместо вызова `getTopicWithMeta()` для каждого сообщения
- Это гарантирует только 2 запроса к БД независимо от количества сообщений

### 3.2. Индексы для null значений
**Проблема:** Индекс `{ tenantId: 1, dialogId: 1, topicId: 1, createdAt: -1 }` может работать неэффективно для запросов с `topicId = null`, так как MongoDB индексирует null значения особым образом.

**Риск:** Медленные запросы для сообщений без топика.

**Решение:**
- Проверить производительность запросов с `topicId = null`
- Возможно, нужен отдельный индекс для сообщений без топика
- Или использовать sparse index (но это не подходит, так как null - валидное значение)

### 3.3. Фильтрация по topic.meta.{param}
**Проблема:** Фильтр `topic.meta.{param},eq,{value}` требует:
1. Поиск в `Meta` по `entityType: 'topic'`
2. Поиск в `Topic` по найденным `topicId`
3. Поиск в `DialogMember` для получения диалогов пользователя
4. Пересечение результатов

**Риск:** Медленные запросы при большом количестве топиков и мета-тегов.

**Решение:** ✅ Добавить индекс на `Meta`: `{ tenantId: 1, entityType: 1, key: 1, value: 1 }`
- Индекс добавлен в план обновления модели `Meta`
- Ускоряет поиск мета-тегов топиков по значению при фильтрации диалогов
- Дополнительные оптимизации (кэширование, ограничение сложности фильтров) - опционально

## 4. Консистентность данных

### 4.1. Создание DialogStats при создании диалога
**Проблема:** При создании диалога нужно создать `DialogStats` с начальными значениями. Но если создание `DialogStats` упадет, диалог будет создан без статистики.

**Риск:** Отсутствие статистики для диалога, ошибки при получении `stats` в API.

**Решение:** ✅ Использовать транзакцию для атомарного создания диалога и `DialogStats`
- При создании диалога в `dialogController.create()` использовать транзакцию MongoDB
- Создавать `DialogStats` сразу после создания диалога внутри той же транзакции
- Если создание `DialogStats` упадет, диалог не должен быть создан (откат транзакции)
- Это гарантирует, что каждый диалог всегда имеет запись `DialogStats`
- Добавлено в план обновления `dialogController.js`

### 4.2. Инициализация UserTopicStats
**Проблема:** При создании сообщения в топике создается запись в `UserTopicStats`. Но если пользователь уже был участником диалога до создания топика, у него может не быть записи в `UserTopicStats` для этого топика.

**Риск:** При первом сообщении в топике создастся запись с `unreadCount: 1`, что корректно. Но если пользователь уже прочитал другие сообщения в топике до этого - счетчик будет неверным.

**Решение:** Это не проблема, так как счетчик создается при первом сообщении в топике, и это корректное поведение.

### 4.3. События и Updates
**Проблема:** В `update-worker` при создании `MessageUpdate` нужно получить топик через `getTopicWithMeta()`. Но если топик был удален между созданием события и обработкой в worker - `getTopicWithMeta()` вернет `null`.

**Риск:** В Update будет `message.topic: null` даже если в событии был `topicId`.

**Решение:** 
- Это корректное поведение - если топик удален, то `topic: null`
- Но нужно убедиться, что это не приводит к ошибкам в клиентском приложении

## 5. Обработка ошибок

### 5.1. Ошибка при получении topic в API
**Проблема:** Если `getTopicWithMeta()` упадет с ошибкой при обогащении сообщений, весь запрос упадет.

**Риск:** API будет возвращать 500 вместо частичных данных.

**Решение:** ✅ Добавлено в план обработка ошибок:
- Обернуть `getTopicWithMeta()` и `getTopicsWithMetaBatch()` в try/catch во всех контроллерах
- При ошибке возвращать `topic: null` вместо падения запроса
- Логировать ошибки для отладки
- Это гарантирует, что API всегда возвращает данные, даже если получение топика упало

### 5.2. Ошибка при обновлении счетчиков
**Проблема:** Если обновление `UserTopicStats` или `UserDialogStats` упадет при создании сообщения, сообщение уже будет создано, но счетчики не обновятся.

**Риск:** Некорректные счетчики непрочитанных сообщений.

**Решение:**
- Использовать транзакции для атомарности
- Или обрабатывать ошибки и логировать для последующего исправления
- Добавить функцию пересчета счетчиков

## 6. Edge cases

### 6.1. Сообщения без топика при фильтрации
**Проблема:** Фильтр `filter=topicId,eq,null` должен находить сообщения с `topicId = null`. Но в MongoDB нужно использовать `{ topicId: null }` или `{ topicId: { $exists: false } }`.

**Риск:** Неправильная фильтрация сообщений без топика.

**Решение:** Убедиться, что парсер фильтров корректно обрабатывает `null` значения.

### 6.2. Топик удален, но сообщения остались
**Проблема:** ~~Если в будущем добавится удаление топиков, сообщения с `topicId` удаленного топика останутся в БД.~~

**Решение:** ✅ **Удаление топиков запрещено** - эта проблема не возникает, так как топики нельзя удалять.

### 6.3. Создание топика в несуществующем диалоге
**Проблема:** Нужно проверять существование диалога перед созданием топика.

**Риск:** Создание топика для несуществующего диалога.

**Решение:** Добавить валидацию в `topicController.createTopic`.

### 6.4. Дублирование topicId в разных диалогах
**Проблема:** `topicId` уникален глобально (unique index), но составной ключ `{ tenantId, dialogId, topicId }` уникален только в рамках диалога. Это может привести к путанице.

**Риск:** Если случайно использовать `topicId` из другого диалога, может быть ошибка уникальности.

**Решение:** Это не проблема, так как `topicId` уникален глобально, и это правильно.

## 7. Производительность запросов

### 7.1. Получение всех топиков диалога
**Проблема:** При получении списка топиков для каждого топика нужно загрузить мета-теги отдельным запросом (если не используется агрегация).

**Риск:** N+1 проблема при получении списка топиков.

**Решение:**
- Использовать агрегацию MongoDB для загрузки мета-тегов вместе с топиками
- Или загрузить все мета-теги одним запросом и собрать map

### 7.2. Фильтрация диалогов по topic.meta
**Проблема:** Фильтр `topic.meta.{param},eq,{value}` требует множественных запросов и пересечений.

**Риск:** Медленные запросы при большом количестве топиков.

**Решение:**
- Оптимизировать запросы через правильные индексы
- Возможно, ограничить использование таких фильтров
- Добавить кэширование результатов

## 8. Миграция и обратная совместимость

### 8.1. Существующие сообщения без topicId
**Проблема:** Все существующие сообщения имеют `topicId = null` (или поле отсутствует). При добавлении поля `topicId` в схему `Message`, существующие документы получат `topicId: null`.

**Риск:** Минимальный, так как это ожидаемое поведение.

**Решение:** Это корректно, миграция не требуется.

### 8.2. Отсутствие DialogStats для существующих диалогов
**Проблема:** Существующие диалоги не имеют записей в `DialogStats`. При запросе статистики будет ошибка или нужно возвращать дефолтные значения.

**Риск:** Ошибки при получении статистики диалогов.

**Решение:** ✅ Добавлено в план:
- Создавать `DialogStats` лениво при первом запросе в `dialogController.getAll` и `getById`
- Создать скрипт миграции `src/scripts/migrate-dialog-stats.js` для создания `DialogStats` для всех существующих диалогов
- Скрипт должен быть идемпотентным (можно запускать несколько раз без дублирования)
- При отсутствии записи пересчитывать значения из реальных данных (Topic.countDocuments, DialogMember.countDocuments, Message.countDocuments)

## 9. Безопасность и права доступа

### 9.1. Проверка прав при создании топика
**Проблема:** Нужно проверять, что пользователь является участником диалога перед созданием топика.

**Риск:** Создание топиков в диалогах, где пользователь не является участником.

**Решение:** Добавить проверку через `DialogMember` в `topicController.createTopic`.

### 9.2. Проверка прав при получении топиков
**Проблема:** При получении списка топиков нужно проверять, что пользователь является участником диалога.

**Риск:** Утечка информации о топиках диалогов, где пользователь не является участником.

**Решение:** Добавить проверку через `DialogMember` в `topicController.getDialogTopics`.

## 10. Логика обновления счетчиков

### 10.1. Обновление unreadCount при прочтении сообщения
**Проблема:** При прочтении сообщения (изменении статуса на `read`) нужно обновить `unreadCount` в `UserTopicStats` для топика сообщения. Но в текущем плане это не описано явно.

**Риск:** Счетчики топиков не будут обновляться при прочтении сообщений.

**Решение:** ✅ Добавлено в план обновление `updateMessageStatus`:
- При изменении статуса сообщения на `read` обновлять счетчики `unreadCount`
- Использовать транзакцию MongoDB для атомарного обновления счетчиков
- Если `topicId` указан - уменьшить `unreadCount` в `UserTopicStats` для топика и общий счетчик в `UserDialogStats`
- Если `topicId = null` - уменьшить только общий счетчик в `UserDialogStats`
- Если обновление счетчиков упадет, статус сообщения не должен быть обновлен (откат транзакции)

### 10.2. Обновление счетчиков при удалении сообщения
**Проблема:** Если в будущем добавится удаление сообщений, нужно обновлять счетчики (`messageCount` в `DialogStats`, `unreadCount` в `UserTopicStats`).

**Риск:** Некорректные счетчики после удаления сообщений.

**Решение:** Учесть это при добавлении функциональности удаления сообщений.

## 11. Производительность индексов

### 11.1. Составной индекс с topicId
**Проблема:** Индекс `{ tenantId: 1, dialogId: 1, topicId: 1, createdAt: -1 }` может быть большим, если много сообщений с разными топиками.

**Риск:** Медленное создание индекса, большой размер индекса.

**Решение:** 
- Проверить размер индекса
- Возможно, использовать частичный индекс для оптимизации

### 11.2. Индекс для UserTopicStats
**Проблема:** Индекс `{ tenantId: 1, userId: 1, dialogId: 1, topicId: 1 }` будет расти с количеством топиков и пользователей.

**Риск:** Большой размер индекса, медленные запросы.

**Решение:** 
- Мониторить размер индекса
- Оптимизировать запросы

## 12. Консистентность при параллельных операциях

### 12.1. Параллельное создание сообщений в одном топике
**Проблема:** Если два сообщения создаются одновременно в одном топике, оба будут пытаться обновить `UserTopicStats.unreadCount` и `UserDialogStats.unreadCount`.

**Риск:** Race condition, некорректные счетчики.

**Решение:** 
- Использовать атомарные операции `$inc` (уже используется)
- Это должно решить проблему, но нужно проверить

### 12.2. Параллельное создание топиков
**Проблема:** Если два топика создаются одновременно в одном диалоге, оба будут пытаться обновить `DialogStats.topicCount`.

**Риск:** Race condition, некорректный счетчик.

**Решение:** 
- Использовать атомарные операции `$inc` (уже используется)
- Это должно решить проблему

## Рекомендации по приоритетам

### Критичные (нужно решить до реализации):
1. ✅ Валидация `topicId` при создании сообщения
2. ✅ Проверка прав доступа при работе с топиками
3. ✅ Обработка ошибок при получении `topic` в API
4. ✅ Использование транзакций для атомарности обновления счетчиков

### Важные (нужно решить в процессе реализации):
5. ✅ Оптимизация N+1 проблемы при получении `topic` для сообщений
6. ✅ Функция пересчета счетчиков для восстановления консистентности
7. ✅ Ленивое создание `DialogStats` для существующих диалогов
8. ✅ Обновление `unreadCount` при прочтении сообщений в топиках

### Желательные (можно решить после реализации):
9. ✅ Мониторинг размера индексов
10. ✅ Кэширование результатов фильтрации по мета-тегам
11. ✅ Документация по обработке edge cases
