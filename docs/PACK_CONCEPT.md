# Pack: виртуальный диалог из нескольких диалогов

## Идея

**Pack** — сущность, объединяющая 0, 1 или более диалогов в один «виртуальный» диалог: общий список, счётчики непрочитанного по паку, единая точка входа в UI (папка, канал, проект). Один диалог может входить в **несколько паков**. Привязки к пользователям нет — паки общие на тенанта; при этом каждый пользователь получает список только тех паков, в диалогах которых он состоит (например, `GET /api/users/:userId/packs`).

Сообщения и участники остаются в реальных диалогах; пак — слой агрегации и представления. На паки можно вешать **мета-теги** и использовать их в **фильтрах** запросов.

---

## Текущий контекст (напоминание)

- **Dialog**: минимальная сущность (`dialogId`, `tenantId`, `createdAt`). Участники — в `DialogMember`, мета — в `Meta`, счётчики диалога — в `DialogStats` (topicCount, memberCount, messageCount).
- **UserDialogStats**: `(tenantId, userId, dialogId, unreadCount)` — непрочитанные по диалогу для пользователя.
- **UserStats**: агрегаты по пользователю (dialogCount, unreadDialogsCount и т.д.).
- События: `dialog.create`, `dialog.member.add`, `message.create` и т.д. — всё привязано к одному `dialogId`.
- API списка диалогов пользователя: `GET /api/users/:userId/dialogs` — по `DialogMember` + фильтры + подмешивание UserDialogStats, DialogStats, meta.

---

## Возможности Pack

1. **Единый «входящий» по паку**  
   Вместо N диалогов пользователь видит один пак (например, «Поддержка», «Проект X»). В паке — объединённый список диалогов или общий поток (если решим показывать сообщения из всех диалогов пака).

2. **Счётчик непрочитанного по паку**  
   Один badge: сумма непрочитанных по всем диалогам пака для данного пользователя (или «есть непрочитанное в паке»). Удобно для папок/категорий.

3. **Уведомления и события на уровне пака**  
   Подписка на «что-то изменилось в паке» (новое сообщение в любом диалоге пака, новый участник в любом диалоге) — для пуша, бейджей, ленты.

4. **Фильтрация и навигация**  
   Список диалогов пользователя с группировкой по пакам; фильтр «только диалоги из пака X»; быстрый переход «все диалоги пака».

5. **Права и видимость**  
   Пак как область видимости: «доступ к паку» = доступ к входящим в него диалогам (если политика будет такой). Либо пак — только UI-группировка без отдельной авторизации.

6. **Аналитика и отчёты**  
   Метрики по паку: сумма сообщений, участников, активность по всем диалогам пака.

---

## Счётчики

### Принято

- **UserPackStats** (userId, packId, unreadCount) — нужны: быстрый список «паки с непрочитанным», бейджи по паку для пользователя.
- **PackStats** (packId, messageCount, uniqueMemberCount, sumMemberCount, **uniqueTopicCount**, **sumTopicCount**) — нужны: агрегаты по паку без привязки к пользователю для админки/аналитики. **uniqueMemberCount** — число уникальных userId по всем диалогам пака; **sumMemberCount** — сумма memberCount по диалогам пака; **uniqueTopicCount** — число уникальных topicId по всем диалогам пака; **sumTopicCount** — сумма topicCount по диалогам пака.
- **Обновление**: синхронно в API при операциях или асинхронно воркером по событиям — **на потом** (при проектировании выбрать: консистентность vs нагрузка на API).

### Варианты (для справки)

| Подход | Плюсы | Минусы |
|--------|--------|--------|
| Только на лету | Нет новых коллекций, всегда консистентно с диалогами | Нагрузка при частых запросах списка паков с unread |
| UserPackStats (userId, packId, unreadCount) | Быстрый список «паки с непрочитанным», бейджи | Дублирование логики обновления unread (диалог + пак), рассинхрон при ошибках |
| Гибрид: кэш/материализация с TTL | Баланс скорости и простоты | Сложнее: инвалидация при событиях в диалогах пака |

---

## События

### Какие события могут происходить (семантика)

**1. Изменение состава или жизненного цикла пака** (источник — API при операциях с паками):

| Что произошло | Описание |
|---------------|----------|
| Пак создан | Создан новый пак (пустой или с диалогами). |
| Пак удалён | Пак удалён из системы; каскадно удаляются PackLink, PackStats, UserPackStats. |
| Диалог добавлен в пак | Диалог связан с паком (запись PackLink). |
| Диалог удалён из пака | Связь диалога с паком удалена (запись PackLink удалена). |

**2. Активность в диалоге, входящем в пак**:

- Всё, что происходит внутри пака, уже описывается **существующими событиями** (`message.create`, `dialog.member.add`, `message.read` и т.д.). Отдельных событий уровня пака (**в т.ч. `pack.activity`**) **не вводим**.
- Счётчики пака (UserPackStats, PackStats) обновляет воркер по этим же событиям (по `dialogId` находит паки через PackLink и пересчитывает).
- Подписчик, которому нужно «что-то изменилось в паке X», подписывается на существующие события и сам определяет паки по `dialogId`: держит кэш «dialogId → packIds», обновляемый по событиям `pack.dialog.add` и `pack.dialog.remove`.

### Именование событий пака

**События пака** — изменение состава и жизненного цикла (четыре типа):

| Событие | Когда публикуется |
|---------|-------------------|
| `pack.create` | После создания пака. |
| `pack.delete` | После удаления пака. |
| `pack.dialog.add` | После добавления диалога в пак. |
| `pack.dialog.remove` | После удаления диалога из пака. |

**Уведомления при изменении счётчиков пака** (два типа):

| Событие | Когда публикуется | Payload (примерно) |
|---------|-------------------|--------------------|
| `pack.stats.updated` | После пересчёта PackStats воркером. | packId, при необходимости messageCount, uniqueMemberCount, sumMemberCount, uniqueTopicCount, sumTopicCount. |
| `user.pack.stats.updated` | После пересчёта UserPackStats воркером (unreadCount для userId+packId изменился). | userId, packId, unreadCount. |

Событий уровня «активность в паке» (pack.activity) нет: всё уже есть в `message.create`, `dialog.member.add` и т.д.; подписчики используют их и кэш dialogId → packIds.

**3. Изменение счётчиков пака** (источник — воркер после пересчёта UserPackStats / PackStats):

- Когда воркер обновляет **UserPackStats** (например, unreadCount для userId+packId изменился) или **PackStats** (messageCount, uniqueMemberCount и т.д. для packId), имеет смысл публиковать **уведомление об изменении счётчиков**, чтобы UI и пуш могли обновить бейджи и итоги без опроса API.
- **Предлагаемые события**:
  - `pack.stats.updated` — изменились агрегаты по паку (PackStats). Payload: packId, при необходимости поля messageCount, uniqueMemberCount, sumMemberCount, uniqueTopicCount, sumTopicCount (или только флаг «пересчитано»). Подписчики: админка, аналитика.
  - `user.pack.stats.updated` (или `pack.user.stats.updated`) — изменились счётчики пака для пользователя (UserPackStats). Payload: userId, packId, unreadCount. Подписчики: клиент пользователя для обновления бейджа по паку.
- **Когда публиковать**: после успешной записи в UserPackStats / PackStats в том же воркере, который обрабатывает message.create, message.read, pack.dialog.add, pack.dialog.remove и пересчитывает счётчики. Публиковать только если значение реально изменилось (или всегда — решить при реализации).
- **Итог**: уведомления при изменении счётчиков пака — **да**, отдельные типы событий для «статы пака обновились» и «статы пака для пользователя обновились»; точные имена и формат payload — зафиксировать при проектировании.

---

## Модель данных пака (уточнённая)

### Принято

- **Один диалог — несколько паков**: диалог может входить в любое число паков. Хранение состава: отдельная коллекция `PackLink` (packId, dialogId, addedAt — дата добавления). Порядок по умолчанию — от свежих (по addedAt desc). См. ниже.
- **Без привязки к пользователям**: паки общие на тенанта. Видимость для пользователя определяется через участие в диалогах: пользователь видит только паки, в которых хотя бы один диалог содержит его как участника.
- **API списка паков пользователя**: `GET /api/users/:userId/packs` — паки, в чьих диалогах есть данный userId (через DialogMember). Пагинация, фильтры, сортировка — по аналогии с диалогами.
- **Мета-теги на паках**: entityType `pack`, entityId = packId. Те же механизмы, что у dialog/topic: PUT/DELETE meta, фильтры в запросах вида `(meta.category,eq,support)` при списке паков.
- **Создание и редактирование паков** — через API с ключом (как и остальные сущности в системе). Отдельной привязки к пользователю или роли нет: доступ определяется правами API-ключа (tenant, permissions).

### Минимум модели

- **Pack**: `packId`, `tenantId`, `createdAt`. Состав — в отдельной коллекции **PackLink** (packId, dialogId, **addedAt** — дата добавления диалога в пак). Мета — в коллекции Meta (entityType = `pack`).
- Ограничение по размеру: в паке может быть **0, 1 или более** диалогов (пустой пак, «папка из одного», несколько — все варианты допустимы).

---

## Дефолтный пак

**Вопрос**: должны ли все диалоги по умолчанию входить в один «дефолтный» пак (например, «Все» / «Без категории»), или паки только явные — диалог может вообще не входить ни в один пак?

### Варианты

| Вариант | Описание | Плюсы | Минусы |
|--------|----------|--------|--------|
| **A. Нет дефолтного пака** | Паки только явные. Диалог без паков — просто не в списке ни одного пака. | Простая модель, нет «виртуального» пака на каждый диалог. | В UI «все диалоги» = все диалоги пользователя; «по пакам» — только те, что в паках. Нужно явно различать «все» и «по пакам». |
| **B. Системный дефолтный пак** | Один фиксированный пак (например, `packId = "default"`), в который автоматически входят все диалоги тенанта. | Единообразно: у каждого диалога всегда есть хотя бы один пак; фильтр «пак = default» даёт «все диалоги». | Все диалоги в одном паке — раздувание состава; при 10k диалогах хранить 10k id в паке или генерировать членство на лету («default» = «все dialogId»). |
| **C. Дефолтный пак как «пустая категория»** | При создании диалога его можно опционально добавить в пак «Без категории»; если не добавили ни в какой — он не в паках (как A). Либо «Без категории» — пак с пустым/спец. именем, куда попадают диалоги, не добавленные ни в один другой пак (вычисляется на лету при запросе). | Баланс: есть понятие «без категории» без хранения всех id в одном паке. | Логика «без категории» чуть сложнее (отдельный кейс в API/UI). |

**Принято**: вариант **A** — паки только явные; диалог может не входить ни в один пак. В UI «все диалоги» = все диалоги пользователя; «по пакам» — только те, что в паках.

---

## Паки в событиях: как не раздувать payload

**Проблема**: при событии в диалоге (например, `message.create`) подписчик может хотеть знать «в каких паках этот диалог». Если в каждое событие класть массив `packIds` — лишние данные и рост размера сообщений.

**Принято**: **отдельных событий уровня пака не публикуем** (ни `pack.activity`, ни зеркало типов). События диалога остаются как есть, без packIds. Подписчик, которому нужны паки по диалогу:
- подписывается на существующие события (`message.create`, `dialog.member.add` и т.д.);
- держит локальный кэш «dialogId → packIds» и обновляет его по событиям `pack.dialog.add` и `pack.dialog.remove`;
- по пришедшему событию с `dialogId` смотрит в кэш и определяет, в каких паках диалог.

Так не раздувается payload, не множатся сообщения в очереди, а вся информация о паках получается из четырёх событий управления паками и кэша.

---

## API (уточнённое)

- **Список паков пользователя**: `GET /api/users/:userId/packs` — паки, в чьих диалогах пользователь участвует. Query: `page`, `limit`, `filter`, `sort`. Фильтры по полям пака и по **meta** (например, `(meta.category,eq,support)`). Ответ: список паков, в каждом — состав dialogIds и/или счётчики (если введём).
- **Один пак**: `GET /api/users/:userId/packs/:packId` или `GET /api/packs/:packId` (с проверкой доступа: пользователь должен быть участником хотя бы одного диалога пака).
- **Список диалогов пользователя**: поле `packIds` в ответ не включать. Отдельный endpoint — **список паков для диалога**: GET /api/users/:userId/dialogs/:dialogId/packs или GET /api/dialogs/:dialogId/packs (список паков, в которые входит данный диалог).
- **Сообщения**: остаётся «сообщения одного диалога» (`GET /api/dialogs/:dialogId/messages`). **Объединённый поток по паку** — нужен: `GET /api/packs/:packId/messages` (или `GET /api/users/:userId/packs/:packId/messages`) — все сообщения из диалогов пака в одном потоке с пагинацией и сортировкой по времени (детали пагинации и производительности — при проектировании).

---

## Соображения и риски

1. **Производительность**  
   Если счётчики по паку считаются на лету — при большом числе диалогов в паке и частых запросах нужны индексы и возможно кэш. Если введём материализованные счётчики — нужна надёжная синхронизация с событиями диалогов.

2. **Права**  
   Просмотр пака должен учитывать: пользователь имеет доступ только к тем диалогам пака, где он участник. Не показывать в паке диалоги, где пользователя нет.

3. **Консистентность**  
   При удалении диалога или удалении пользователя из диалога — нужно ли автоматически убирать диалог из пака / пересчитывать состав пака. При удалении пака — только удалить сущность пака, диалоги остаются.

4. **Обратная совместиость**  
   Текущий API «диалоги пользователя» не обязан сразу возвращать паки; можно ввести опциональный query-параметр `includePacks=true` и поле `packIds` у диалогов, либо отдельные эндпоинты для паков.

5. **Виртуальность**  
   Пак не заменяет диалог: создание сообщения, участники, топики — по-прежнему в рамках диалога. Пак — только способ группировки и агрегации для отображения и уведомлений.

6. **Размер событий**  
   Не дублировать в каждое событие диалога список packIds при большом числе паков на диалог — см. раздел «Паки в событиях».

---

## Вопросы для решения перед проектированием

**Уже зафиксировано**: один диалог — в нескольких паках; без привязки к пользователям; список паков пользователя — `GET /api/users/:userId/packs`; мета на паках и фильтры по meta; **дефолтный пак — вариант A**; **состав пака — отдельная коллекция** PackLink (packId, dialogId, addedAt); уникальность (packId, dialogId); при повторном добавлении диалога в пак — идемпотентный успех без смены addedAt; порядок диалогов в паке по умолчанию — от свежих (addedAt desc); **счётчики** — UserPackStats и PackStats (uniqueMemberCount, sumMemberCount, uniqueTopicCount, sumTopicCount в PackStats; синхронное или асинхронное обновление — решить при проектировании); **события пака** — четыре типа управления (pack.create, pack.delete, pack.dialog.add, pack.dialog.remove) и два типа уведомлений при изменении счётчиков (pack.stats.updated, user.pack.stats.updated); **событий уровня пака** (pack.activity и т.п.) **нет**, подписчики используют существующие события и кэш dialogId → packIds; **единый поток сообщений пака** — да; **создание/редактирование паков** — через API с ключом; **каскад**: при удалении диалога из системы — удалять записи PackLink; при удалении пака — каскадно удалять PackLink, PackStats, UserPackStats по packId; **пустой пак**: пак с 0 диалогов допустим, пак не удалять и не архивировать при удалении последнего диалога; **размер пака**: допустимы 0, 1 или более диалогов (ограничения на минимум нет); **tenant**: пак и все диалоги в паке — один tenantId; при добавлении диалога в пак проверять совпадение tenantId; **формат packId**: pck_[a-z0-9]{20}, генерация при создании пака; **packIds в списке диалогов** не возвращать; отдельный endpoint для списка паков диалога (GET .../dialogs/:dialogId/packs или .../users/:userId/dialogs/:dialogId/packs); **доступ к пустому паку**: в админке пак по packId можно увидеть и удалить; в списке пользователя пустой пак не возвращается.

**Остаётся решить** (на этапе проектирования):

- Синхронное или асинхронное обновление UserPackStats и PackStats.
- Детали пагинации и индексов для `GET /api/packs/:packId/messages`.

Все ключевые концептуальные решения приняты; далее — детальная модель данных, API и план внедрения (модель пака + PackLink + meta + фильтры → счётчики → события и поток сообщений пака).

---

## Слабые места и риски концепции

Ниже — узкие места, неоднозначности и риски, которые стоит учесть при проектировании и реализации.

### 1. События уровня пака не публикуются

**Принято**: отдельные события уровня пака (pack.activity и т.п.) **не публикуем**. Всё, что происходит внутри пака, уже есть в существующих событиях (message.create, dialog.member.add и т.д.). Подписчик, которому нужны паки по диалогу, держит кэш dialogId → packIds (обновляется по pack.dialog.add, pack.dialog.remove) и по пришедшему событию смотрит в кэш.

**Итог**: нагрузка на очередь не растёт от паков; дублирования сообщений нет.

### 2. Семантика агрегатов PackStats

**PackStats**: messageCount, **uniqueMemberCount**, **sumMemberCount**, **uniqueTopicCount**, **sumTopicCount** по паку.

**Принято**:  
- **uniqueMemberCount** — число уникальных userId по всем диалогам пака (один пользователь, участник нескольких диалогов пака, считается один раз).  
- **sumMemberCount** — сумма memberCount по диалогам пака («всего участников-мест», для аналитики нагрузки).  
- **uniqueTopicCount** — число уникальных topicId по всем диалогам пака (один топик считается один раз; при отвязке топика от диалога семантика сохраняется).  
- **sumTopicCount** — сумма topicCount по диалогам пака (сумма DialogStats.topicCount по диалогам пака).

### 3. Видимость пака vs состав пака

**Принято**: пользователь видит только паки, в которых участвует хотя бы в одном диалоге; в паке показывать только диалоги, где он участник («не показывать диалоги, где пользователя нет»).

**Неоднозначность**: PackStats (messageCount, uniqueMemberCount, sumMemberCount, uniqueTopicCount, sumTopicCount) считаются по **всему** паку или только по диалогам, доступным текущему пользователю? Если по всему паку — в UI пользователь видит «пак: 100 сообщений», но сам имеет доступ к части диалогов (например, 20 сообщений). Если по «своим» диалогам — то счётчики зависят от userId, и PackStats не могут быть одной записью на пак без привязки к пользователю.

**Рекомендация**: разделить: **PackStats** — агрегаты по всему паку (messageCount, uniqueMemberCount, sumMemberCount, uniqueTopicCount, sumTopicCount — для админки/аналитики); для пользователя в API списка паков возвращать **UserPackStats** (unreadCount) и опционально «доступный» messageCount/uniqueMemberCount по диалогам пака, где он участник (считаться на лету или кэш).

### 4. Авторизация и семантика userId в path

**API**: `GET /api/users/:userId/packs` — «паки, в диалогах которых участвует userId».

**Вопрос**: в системе доступ по API-ключу (tenant, permissions). Откуда берётся `userId` в path — это «текущий пользователь» (идентичность из ключа) или произвольный userId (например, админ запрашивает паки другого пользователя)? Если произвольный — нужна явная политика: какой ключ может запрашивать паки для какого userId (только себя / только свой tenant / админ по любому userId в tenant).

**Рекомендация**: зафиксировать в API: либо `userId` в path всегда = идентичность ключа (тогда path можно упростить до `GET /api/me/packs`), либо явно описать, кто может указывать чужой userId.

### 5. Единый поток сообщений пака: производительность и ответ

**Принято**: `GET /api/packs/:packId/messages` — все сообщения диалогов пака в одном потоке.

**Риски**:  
- Запрос по сути — объединение N диалогов (по PackLink), сортировка по времени, пагинация. При большом числе диалогов в паке и большом объёме сообщений агрегация тяжёлая; нужны индексы (например, по (dialogId, createdAt)) и стратегия пагинации (курсор по (createdAt, messageId)).  
- В ответе каждое сообщение должно нести **dialogId** (и при необходимости topicId), иначе клиент не знает, в какой диалог вести при клике. Формат ответа и контракт — зафиксировать при проектировании.

**Рекомендация**: на этапе проектирования выбрать стратегию запроса (агрегация по Message + filter by dialogId in [...], или отдельный материал. представление) и формат элемента (message + dialogId [+ topicId]).

### 6. Каскад при удалении диалога и пустые паки

**Принято**:  
- При **удалении диалога из системы** — автоматически удалять записи PackLink с этим dialogId (каскад), чтобы не оставались ссылки на несуществующий диалог.  
- **Пак с 0 диалогов допустим**: при удалении последнего диалога из пака (pack.dialog.remove) пак не удалять и не архивировать. Пока в паке есть хотя бы один диалог — пак не удалять; пак без диалогов — валидное состояние (пустой пак).

### 7. Размер пака: 0, 1 или более диалогов

**Принято**: пак может содержать **0, 1 или более** диалогов. Допустимы: пустой пак (0), пак из одного диалога («папка из одного»), пак из нескольких диалогов. Ограничения на минимальное число диалогов нет.

### 8. Имя коллекции состава пака

**Принято**: использовать **PackLink** (packId, dialogId, addedAt) — связка «диалог входит в пак» с датой добавления. Имя явно отличается от **DialogMember** (userId, dialogId — участник-пользователь диалога), путаницы «member = пользователь» нет. Порядок по умолчанию — по addedAt desc (от свежих).

### 9. Порядок диалогов в паке

**Принято**: в **PackLink** сохранять **дату добавления** (addedAt) диалога в пак. По умолчанию диалоги в паке отображать **от свежих** (сортировка по addedAt desc — недавно добавленные первыми).

### 10. Tenant при добавлении диалога в пак

**Принято**: пак и все его диалоги — в рамках одного **tenantId**. При добавлении диалога в пак (pack.dialog.add) проверять: tenantId диалога и tenantId пака совпадают; иначе — отказ.

---

## Повторный анализ: тонкие моменты и открытые вопросы

Ниже — дополнительные слабые места, краевые случаи и вопросы для уточнения при проектировании.

### A. Уникальность и идемпотентность PackLink

**Принято**: в коллекции PackLink действует **уникальность (packId, dialogId)** — один диалог в паке только один раз. При повторном вызове «добавить диалог в пак» (диалог уже в паке) — **идемпотентный успех без смены addedAt**: возвращать успех, запись не менять, addedAt остаётся прежним.

### B. Каскад при удалении пака

**Принято**: при **удалении пака** (pack.delete или аналог) каскадно удалять:
- все записи **PackLink** с этим packId;
- записи **PackStats** для этого packId;
- записи **UserPackStats** для этого packId.

Иначе останутся «сиротские» записи по несуществующему паку.

### C. UserPackStats при «уходе» пользователя из пака

**Тонкий момент**: пользователь видит пак, только если участвует хотя бы в одном диалоге этого пака. При удалении из пака последнего диалога, в котором был пользователь (или удалении пользователя из этого диалога), пользователь фактически «выбыл» из пака — пак больше не должен отображаться в его списке. Запись UserPackStats (userId, packId, unreadCount) при этом может остаться. При следующем запросе GET /api/users/:userId/packs пак не вернётся (в паке нет диалогов с его участием), но запись в UserPackStats — «мусор».

**Вопрос**: при удалении диалога из пака или удалении пользователя из диалога — нужно ли помечать/удалять записи UserPackStats для пар (userId, packId), для которых в паке больше не осталось диалогов с участием этого пользователя? Или считать UserPackStats только для текущего состава «пользователь видит пак» и не хранить записи для «пустых для пользователя» паков?

### D. Имена типов событий пака

**Принято** (см. раздел «События» выше): события пака — **четыре типа** управления (`pack.create`, `pack.delete`, `pack.dialog.add`, `pack.dialog.remove`) и **два типа** уведомлений при изменении счётчиков (`pack.stats.updated`, `user.pack.stats.updated`). Событий уровня «активность в паке» (pack.activity и т.п.) **нет**: всё, что происходит внутри пака, уже описывается существующими событиями; подписчики используют их и кэш dialogId → packIds.

### E. Формат packId

**Принято**: формат **packId** — `pck_[a-z0-9]{20}` (аналогично dlg_xxx, topic_xxx). Генерация при создании пака (в API или в модели). Уникальность в рамках тенанта (или глобально — как у dialogId, topicId).

### F. Порядок паков в списке пользователя

**Вопрос**: порядок по умолчанию для GET /api/users/:userId/packs — по чему? По createdAt пака, по последней активности в паке (например, max lastMessageAt по диалогам пака), по количеству непрочитанных (unreadCount desc), по имени (meta)? Сейчас задан порядок диалогов внутри пака (addedAt desc), но не порядок самих паков в списке.

**Вопрос**: зафиксировать сортировку по умолчанию для списка паков пользователя (и доступные поля для sort).

### G. Список паков для диалога

**Принято**: в ответ GET /api/users/:userId/dialogs поле **packIds не включать**. Отдельный **endpoint для получения списка паков диалога** — напр. GET /api/users/:userId/dialogs/:dialogId/packs или GET /api/dialogs/:dialogId/packs (с проверкой доступа). Клиент при необходимости запрашивает паки по каждому диалогу; payload списка диалогов не раздувается.

### H. Удаление пака: есть ли операция

**Вопрос**: предусмотрена ли операция удаления пака (DELETE /api/packs/:packId или аналог)? Если да — см. каскад (п. B). Если паки только создают и редактируют (добавляют/убирают диалоги), но не удаляют — зафиксировать явно.

### I. Доступ к пустому паку

**Принято**: пак с 0 диалогов в списке пользователя GET /api/users/:userId/packs не попадёт (нет диалогов с его участием). По прямому **packId** (GET /api/packs/:packId или аналог): в **админке** такой пак можно **увидеть и удалить** — ключ с правами админки/управления может открыть любой пак по id (в т.ч. пустой), получить состав (пустой) и при необходимости удалить. Для обычного пользовательского контекста доступ к паку — только если он участвует хотя бы в одном диалоге пака; пустой пак по packId для него — 403 или не возвращается в списке.

### J. Топики в PackStats: uniqueTopicCount и sumTopicCount

**Принято**: в PackStats два поля по топикам — **uniqueTopicCount** и **sumTopicCount**.  
- **uniqueTopicCount** — число уникальных topicId по всем диалогам пака (один топик считается один раз; при отвязке топика от диалога семантика сохраняется).  
- **sumTopicCount** — сумма DialogStats.topicCount по диалогам пака («всего топиков-мест» по диалогам пака, для аналитики).
