# Варианты реализации: обновление topicId у сообщения

## Реализовано (вариант 1.3 + 2.2)

Реализованы варианты **1.3** (установка и сброс, без переноса между топиками) и **2.2** (отдельный endpoint):

- **PATCH /api/messages/:messageId/topic** — установить или сбросить топик сообщения.
- Body: `{ "topicId": "topic_..." }` (установить) или `{ "topicId": null }` (сбросить).
- Правила: установить топик можно только если у сообщения нет топика; сбросить — только если топик уже есть. Нельзя менять топик A на топик B.
- Валидация: `topicId` должен существовать и принадлежать тому же диалогу, что и сообщение (`dialogId` топика = `dialogId` сообщения).

Подробнее см. раздел «PATCH /api/messages/:messageId/topic» в [API.md](API.md).

---

## Текущее состояние (до реализации)

- **Создание сообщения (POST /api/dialogs/:dialogId/messages):** поле `topicId` можно задать при создании.
- **Обновление сообщения (PUT /api/messages/:messageId):** разрешено менять только `content`. Поле `topicId` в body не принимается и в БД не обновляется.
- **TOPICS_PLAN.md:** зафиксировано решение «Перемещение сообщений: Нельзя перемещать сообщения между топиками».

Цель документа — зафиксировать варианты и выбранное решение.

---

## 1. Варианты политики (что разрешать)

### 1.1. Оставить как есть (без изменений)

- Не добавлять возможность менять `topicId` после создания сообщения.
- **Плюсы:** совпадает с текущим планом, нет риска путаницы с переносом между топиками, не трогаем счётчики/события.
- **Минусы:** нельзя исправить топик при ошибочной отправке, нельзя «перенести» сообщение в другой топик или в общий поток.

### 1.2. Разрешить только установку topicId (один раз)

- Сообщение без топика (`topicId = null`) можно один раз привязать к топику.
- Сообщение с топиком менять нельзя (или только сбрасывать в `null` — см. ниже).
- **Плюсы:** покрывает кейс «забыли указать топик при создании», минимум логики переноса.
- **Минусы:** асимметричные правила (можно только «привязать», но не «перепривязать»), нужно явно описать в API.

### 1.3. Разрешить установку и сброс (без переноса между топиками)

- Можно: установить `topicId` у сообщения без топика; сбросить `topicId` в `null` у сообщения с топиком.
- Нельзя: менять один топик на другой (A → B).
- **Плюсы:** «привязать» и «отвязать» без полноценного переноса между топиками, проще правила для счётчиков (нет переноса между топиками).
- **Минусы:** всё равно нужна аккуратная работа с UserTopicStats (см. раздел 4).

### 1.4. Полное изменение topicId (включая перенос между топиками)

- Разрешено любое изменение: `null` → topicId, topicId → `null`, topicId_A → topicId_B.
- **Плюсы:** максимальная гибкость для сценариев типа «перенести в другой топик», «вынести в общий чат».
- **Минусы:** сложнее логика счётчиков (unread по топикам), события и аудит; нужно чётко определить семантику «прочитанности» при переносе.

---

## 2. Варианты формы API

### 2.1. Расширить тело PUT /api/messages/:messageId

- Добавить в body опциональное поле `topicId` (string | null).
- Существующее поле `content` остаётся; при обновлении можно передать только `content`, только `topicId` или оба.
- **Плюсы:** один endpoint для обновления сообщения, привычный REST.
- **Минусы:** смешивание «редактирование текста» и «смена топика» в одном запросе; при частичном body нужно явно описать семантику (например, не переданное поле не менять).

### 2.2. Отдельный PATCH /api/messages/:messageId/topic

- Endpoint только для смены топика: body `{ "topicId": "topic_..." }` или `{ "topicId": null }`.
- PUT по-прежнему только для `content`.
- **Плюсы:** чёткое разделение: «редактирование контента» vs «привязка к топику»; проще права и аудит.
- **Минусы:** два запроса, если нужно обновить и текст, и топик.

### 2.3. PATCH /api/messages/:messageId с частичными полями

- Один PATCH, body может содержать подмножество полей: `content`, `topicId` (и при необходимости другие в будущем). Не переданные поля не меняются.
- **Плюсы:** гибко, один запрос для любых комбинаций изменений.
- **Минусы:** отход от текущей схемы «PUT только content»; нужна явная документация и валидация по полям.

---

## 3. Валидация и ограничения

(При любом варианте из п. 1.2–1.4.)

- **Топик существует и принадлежит диалогу:** `topicId` должен существовать в коллекции Topic и иметь тот же `dialogId`, что и сообщение. Иначе 400/404 с понятным кодом (например, `ERROR_TOPIC_NOT_FOUND` или `ERROR_TOPIC_NOT_IN_DIALOG`).
- **Формат:** строка формата `topic_[a-z0-9]{20}` или `null`/пустая строка для сброса.
- **Ограничения по политике:** в зависимости от выбранного варианта (1.2–1.4) — запрет на смену топика A→B, запрет на сброс и т.д., с соответствующими кодами ошибок (например, `ERROR_TOPIC_CHANGE_NOT_ALLOWED`).

---

## 4. Побочные эффекты и согласованность данных

### 4.1. UserTopicStats / UserDialogStats (unreadCount)

- Сейчас unread считается по диалогу и по топику (UserTopicStats для участников).
- При **установке topicId** у сообщения без топика: сообщение «уходит» в топик; нужно решить, как учитывать его в unread по топику для тех, кто ещё не прочитал (как правило, считать непрочитанным в целевом топике, если раньше считалось в диалоге).
- При **сбросе topicId** в `null`: сообщение уходит в «общий» поток диалога; аналогично — перенос непрочитанности из топика в общий счётчик диалога.
- При **переносе A → B:** нужно уменьшить unread по топику A (где оно было) и при необходимости учесть в топике B (и/или в общем счётчике), в зависимости от правил «кто что прочитал».

Рекомендация: вынести в отдельный подплан обновление `updateUnreadCount` / логики счётчиков при изменении `topicId` (в т.ч. батчи/миграции, если появятся).

### 4.2. События и Updates

- Имеет смысл генерировать событие типа `message.update` (или отдельное `message.topic.change`, если нужно отличать от редактирования текста) с полными данными сообщения, включая старый и новый `topicId`, чтобы подписчики и update-worker могли синхронизировать кэш и UI.
- В данных события указывать `updatedFields: ['message.topicId']` (и при необходимости `message.content`, если менялось и оно).

### 4.3. Аудит и мета-теги

- По аналогии с редактированием контента можно записывать мета-тег `topicChangedAt` и/или хранить `previousTopicId` в meta при переносе (если нужна история).

---

## 5. Рекомендации (кратко)

1. **Политика:** для минимального риска и совместимости с текущим планом — вариант **1.2** (только установка topicId один раз) или **1.3** (установка + сброс в `null`). Вариант **1.4** — только при явной потребности в переносе между топиками и готовности продумать счётчики и события.
2. **API:** **2.1** (расширить PUT) — проще для клиентов; **2.2** (отдельный PATCH для топика) — если важно разделять «редактирование» и «привязку к топику» в правах и логах.
3. **Обязательно:** обновить TOPICS_PLAN.md и API.md после выбора варианта; описать коды ошибок и поведение счётчиков unread; при необходимости — отдельная задача на изменение логики UserTopicStats/UserDialogStats при смене topicId.

**Выбрано и реализовано:** **1.3** (установка и сброс) + **2.2** (PATCH /api/messages/:messageId/topic). Валидация: topicId должен быть в том же dialogId, что и сообщение — так проще следить за счётчиками.

---

## 6. Открытые вопросы

- Нужен ли сценарий «массовое перенести сообщения топика A в топик B» (отдельный endpoint или скрипт)?
- Нужно ли ограничивать изменение topicId по времени (например, только в течение N минут после создания сообщения)?
- Требуются ли разные права: «редактировать контент» vs «менять топик» (например, только модератор может менять топик)?
