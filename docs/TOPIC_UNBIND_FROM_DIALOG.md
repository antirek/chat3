# Отвязка топика от диалога: анализ и возможности

## Текущее состояние

### Модели и связи

- **Topic**: поле `dialogId` обязательное (`required: true`), формат `dlg_[a-z0-9]{20}`. Уникальность: `(tenantId, dialogId, topicId)`.
- **Message**: `dialogId` обязательное, `topicId` опциональное (сообщение всегда принадлежит диалогу, может быть привязано к топику).
- **DialogStats**: `topicCount` — количество топиков диалога (обновляется при `dialog.topic.create` в update-worker).
- **UserTopicStats**: `(tenantId, userId, dialogId, topicId)` — непрочитанные по топику в контексте диалога участника.

### API

- Топики создаются только в контексте диалога: `POST /api/dialogs/:dialogId/topics`.
- Получение топиков диалога: `GET /api/dialogs/:dialogId/topics`, `GET /api/dialogs/:dialogId/topics/:topicId`.
- Глобальный список топиков тенанта: `GET /api/topics` с фильтром по `dialogId`, `topicId`, `meta.*`.
- Все маршруты топиков в tenant-api завязаны на `:dialogId` в path (кроме `GET /api/topics`).

### События и воркеры

- При создании топика генерируется `dialog.topic.create` с `context.dialogId`, `topic.dialogId`.
- Update-worker по `dialog.topic.create` вызывает `updateDialogTopicCount(tenantId, dialogId, +1)`.
- Удаление топиков в системе не предусмотрено («Топики нельзя удалять», TOPICS_PLAN).

### Где используется dialogId топика

- **topicUtils**: `getTopicById(tenantId, dialogId, topicId)`, `getDialogTopics(tenantId, dialogId)`, `getTopicsWithMetaBatch(tenantId, dialogId, topicIds)` — везде ожидается диалог.
- **userDialogController**: фильтры по топикам (`topic.topicId`, `topic.meta.*`) — по Topic находят `dialogId`, отбор диалогов идёт по принадлежности топика диалогу.
- **messageController**: сообщения диалога с подгрузкой топиков по `dialogId` и списку `topicId`.
- **metaController**: для entityType `topic` при необходимости передаётся `dialogId` из документа Topic.
- **updateUtils**: при сборке Update подставляется топик через `getTopicWithMeta(tenantId, dialogId, topicId)`.

---

## Что значит «отвязать топик от диалога»

Под **отвязкой** здесь понимается возможность иметь топик без диалога: поле `dialogId` у Topic становится опциональным (`null` = топик без диалога).

Варианты семантики:

1. **Архивный топик** — топик «вынут» из диалога, но исторические сообщения остаются в диалоге с тем же `topicId` (как метка), новые в этот топик в этом диалоге не пишутся.
2. **Глобальный (тенантский) топик** — топик уровня тенанта: общая тема, FAQ, база знаний; изначально не привязан к диалогу.
3. **Перенос топика** — смена диалога: `dialogId` меняется с одного на другой (отвязка + привязка к новому диалогу).

Ниже рассматриваются в основном варианты 1 и 2 (опциональный `dialogId` и топики без диалога).

---

## Что потребуется изменить

### 1. Модель Topic

- `dialogId`: сделать необязательным (`required: false`), допустить `null`.
- Валидация: при `dialogId` не null — проверка формата `dlg_...`.
- Индексы:
  - сохранить `(tenantId, dialogId, topicId)` с учётом `null` (в MongoDB null индексируется);
  - уникальность: при опциональном `dialogId` решить, остаётся ли уникальность в рамках диалога и как трактовать `(tenantId, null, topicId)` (один такой топик на тенанта или несколько).

### 2. Сообщения (Message)

- Текущая схема: у сообщения обязателен `dialogId`, опционально `topicId`. Сообщение всегда «живёт» в диалоге.
- Если топик отвязан (dialogId = null):
  - **Вариант A**: сообщения по-прежнему только в диалогах; `topicId` может ссылаться на «сиротский» топик — тогда при отображении топика без диалога нужно агрегировать сообщения по `topicId` из разных диалогов (сложнее запросы и права).
  - **Вариант B**: разрешить сообщения «только в топике» — сделать у Message `dialogId` опциональным при наличии `topicId`. Это крупное изменение (все места, где предполагается наличие dialogId у сообщения).

Рекомендация для первого шага: **вариант A** — не трогать обязательность `dialogId` у Message; отвязанный топик — сущность для метаданных и фильтрации, история сообщений остаётся в диалогах.

### 3. API

- **Создание**:
  - оставить `POST /api/dialogs/:dialogId/topics` для топиков в диалоге;
  - при желании поддержать глобальные топики: `POST /api/topics` (без dialogId в path), в теле опционально `dialogId`; при отсутствии — топик без диалога.
- **Чтение**:
  - `GET /api/topics?filter=(dialogId,eq,null)` — список топиков без диалога;
  - топик по ID: если топик без диалога, текущий `GET /api/dialogs/:dialogId/topics/:topicId` не подходит — нужен маршрут по одному идентификатору, например `GET /api/topics/:topicId` (и при наличии `dialogId` у топика можно редиректить или дублировать логику).
- **Обновление/патч**: для топика без диалога — `PATCH /api/topics/:topicId` (без dialogId в path). Опционально в теле разрешить установку/сброс `dialogId` (привязка/отвязка).

### 4. Утилиты (topicUtils)

- `getTopicById(tenantId, dialogId?, topicId)`: при отсутствии `dialogId` (или при вызове для «глобального» топика) искать по `tenantId` и `topicId`, без условия по `dialogId`.
- `getDialogTopics(tenantId, dialogId)` — без изменений (возвращаем только топики с этим `dialogId`; топики с `dialogId = null` не входят в список топиков диалога).
- `getTopicsWithMetaBatch`: сигнатура может остаться `(tenantId, dialogId, topicIds)` для кейса «сообщения диалога»; для кейса «топики без диалога» — отдельная ветка или вызов с `dialogId = null` и фильтром по `topicId`.

### 5. DialogStats и update-worker

- `topicCount` диалога: считать только топики с `dialogId = dialogId` (при отвязке топика у диалога — уменьшать счётчик, если появится событие типа `dialog.topic.detach` или явное обновление).
- При создании топика без диалога событие может быть, например, `topic.create` (без префикса dialog); update-worker для него не должен вызывать `updateDialogTopicCount`.
- При отвязке (patch topic: dialogId → null) имеет смысл событие `dialog.topic.detach` с `context.dialogId` (старый диалог), чтобы update-worker сделал `updateDialogTopicCount(tenantId, oldDialogId, -1)`.

### 6. UserTopicStats

- Сейчас ключ включает `dialogId`. Для топика без диалога возможны варианты:
  - хранить `dialogId = null` и расширить схему/индексы под null;
  - либо не вести UserTopicStats для «глобальных» топиков (непрочитанные считаются только в контексте диалога).

### 7. Фильтры и userDialogController

- «Диалоги пользователя, у которых есть топик с meta.X» — как сейчас: топики с `dialogId != null` и принадлежащие диалогам пользователя.
- Топики с `dialogId = null` не привязаны ни к какому диалогу пользователя, поэтому в списке «мои диалоги по топикам» они не участвуют, если не ввести отдельный сценарий (например, «глобальные топики пользователя»).

### 8. UI и маршруты

- Страницы вида `/dialogs/:dialogId/topics` остаются для топиков диалога.
- Для топиков без диалога: отдельный раздел, например «Глобальные топики» или «Архив топиков», с вызовом `GET /api/topics?filter=(dialogId,eq,null)` и работой с `GET/PATCH /api/topics/:topicId`.

---

## Возможности, которые открывает отвязка

1. **Глобальные (тенантские) топики**
   - FAQ, база знаний, общие категории — без привязки к конкретному диалогу.
   - Можно использовать в фильтрах и метаданных (например, теги для сообщений из разных диалогов).

2. **Архивирование топиков**
   - «Закрыть» тему в диалоге, не удаляя топик и историю: обнулить `dialogId` у топика, сообщения остаются в диалоге с тем же `topicId`.
   - В диалоге перестаёт отображаться активный топик, но история доступна по фильтру по `topicId` или в отдельном представлении «архив топиков».

3. **Перенос топика между диалогами**
   - Изменение `dialogId` у топика (привязка к другому диалогу). Требует явных правил: что делать с сообщениями (оставлять в старом диалоге с topicId или запрещать перенос при наличии сообщений), с UserTopicStats и счётчиках.

4. **Топик как самостоятельная сущность**
   - Единый идентификатор топика (`topicId`) во всём тенанте; доступ по `GET /api/topics/:topicId` без указания диалога.
   - Удобно для ссылок, интеграций и прав (например, права на «глобальный» топик независимо от диалогов).

5. **Аналитика и отчёты**
   - Группировка по топикам «поверх» диалогов: топики с `dialogId = null` как категории; сообщения с одинаковым `topicId` из разных диалогов можно агрегировать для отчётов.

---

## Риски и ограничения

- **Сложность и объём изменений**: затронуты модели, индексы, API, воркеры, UI. Нужна поэтапная реализация и тесты.
- **Обратная совместимость**: существующие клиенты ожидают обязательный `dialogId` у топика и маршруты с `:dialogId`. Новые маршруты (`/api/topics/:topicId`) и опциональный `dialogId` лучше вводить как расширение, не ломая старые контракты.
- **Семантика сообщений**: если оставить сообщения только в диалогах (вариант A), то «топик без диалога» — это по сути метка/категория; единый «поток сообщений топика» из нескольких диалогов потребует отдельной логики выборки и прав.
- **Счётчики и события**: необходимо чётко определить события отвязки/привязки и обработку `topicCount`, чтобы не было рассинхрона с реальным количеством топиков в диалоге.

---

## Рекомендуемый порядок внедрения

1. **Фаза 1 (модель и чтение)**  
   - Сделать `Topic.dialogId` опциональным (`null` допустим).  
   - Добавить `GET /api/topics/:topicId` (поиск по tenantId + topicId без dialogId).  
   - В `topicUtils.getTopicById` поддерживать вызов без dialogId.  
   - Список топиков без диалога: `GET /api/topics?filter=(dialogId,eq,null)`.

2. **Фаза 2 (создание и обновление)**  
   - `POST /api/topics` с опциональным `dialogId` в теле (глобальный топик при отсутствии).  
   - `PATCH /api/topics/:topicId` для обновления мета и, при необходимости, для установки/сброса `dialogId`.  
   - События: например `topic.create` для топика без диалога; при сбросе dialogId — `dialog.topic.detach` с передачей старого dialogId.

3. **Фаза 3 (воркеры и счётчики)**  
   - В update-worker: не увеличивать `topicCount` для событий топиков без диалога; обрабатывать `dialog.topic.detach` (уменьшение topicCount).  
   - Решить поведение UserTopicStats для топиков с `dialogId = null`.

4. **Фаза 4 (UI)**  
   - Раздел для топиков без диалога и/или архива, использование новых эндпоинтов.

Этот документ можно использовать как основу для детального плана задач (в т.ч. в формате TOPICS_PLAN или отдельного TOPIC_UNBIND_IMPLEMENTATION.md).
