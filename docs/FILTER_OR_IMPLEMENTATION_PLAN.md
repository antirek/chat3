# План реализации опции ИЛИ между условиями в фильтрах

## Цель

Добавить поддержку оператора ИЛИ (`|`) в строковом параметре `filter` с **двумя уровнями** вложенности. Скобки задают порядок; **внутри одной группы оператор один и тот же** (только `&` или только `|`). Фокус — **поиск сущностей по мета-тегам** (топики, диалоги, сообщения).

### Уточнённые правила

1. **Два уровня достаточно** — даже на двух уровнях много комбинаций, например:
   - `((a&b)|c)` — (a И b) ИЛИ c
   - `((a|b)|c)` — (a ИЛИ b) ИЛИ c
   - `((a|b|c|d)&e)` — (a ИЛИ b ИЛИ c ИЛИ d) И e

2. **Один операнд / одна группа без смешивания**  
   При одном операнде всё остаётся как сейчас. Допустимы:
   - один атом: `(meta.name,eq,personal)`
   - цепочка И: `a&b`, `a&b&c&d`  
   **Недопустимо:** `a&b|c` — группировка неочевидна, приоритет операторов не вводим; группы должны быть **явно обозначены скобками**.

3. **Операторы внутри группы не смешиваются**  
   В рамках одной группы — только `&` или только `|`. То есть `(a&b)|(c|d)` и `(a|b)&c` допустимы; `(a&b|c)` внутри одних скобок — нет.

4. **member и $or**  
   Комбинации с `member` в ветках `$or` **пока не поддерживаем** (интересуют в первую очередь комбинации для поиска по мета-тегам).

5. **Валидация и лимиты**  
   Недопустимые формы отклонять с понятной ошибкой (не прошли валидацию). Лимит **5** на число веток в `$or` и на число операндов в одной группе (AND/OR); при превышении — отклонять запрос.

Здесь `filterN` / `a`, `b`, … — атомарные условия вида `(field,op,value)`, например `(meta.name,eq,personal)`.

---

## Текущая реализация (кратко)

- **parseFilters** (`queryParser.ts`): разбивает строку по `&` только на **глубине 0** (вне скобок), каждый фрагмент парсится через **parseFilter** (регулярка `(field,op,value)`), результаты объединяются в один объект (при конфликте ключей — в `$and`).
- **extractMetaFilters**: разбирает уже собранный MongoQuery, вытаскивает `meta`, `meta.*`, `topic`, `member`, `$and`; для `$and` рекурсивно обрабатывает элементы и **склеивает** regular/meta/member в плоские объекты.
- Контроллеры делают: `query = { tenantId, ...regularFilters }`, затем `metaQuery = buildMetaQuery(tenantId, entityType, metaFilters)` и `Object.assign(query, metaQuery)`.

Итого: один «плоский» запрос без `$or`. Поддержки `|` нет.

---

## Вопросы перед реализацией (ответы внесены)

1. **Ограничение глубины** — **ответ:** два уровня достаточно; допустимы комбинации вида `((a&b)|c)`, `((a|b)|c)`, `((a|b|c|d)&e)` и т.п.

2. **Поведение при одном операнде** — **ответ:** при одном операнде всё как сейчас (один объект без `$or`/`$and`). Цепочки только `&` без `|` допустимы: `a&b`, `a&b&c&d`. Строка `a&b|c` без скобок **недопустима** — группировка задаётся только скобками.

3. **memberFilters и $or** — **ответ:** пока не поддерживаем; в приоритете комбинации для поиска по мета-тегам.

4. **Скобки и операторы в группе** — **ответ:** скобки задают порядок; внутри одной группы операторы не смешиваются (только `&` или только `|`).

---

## Дополнительные вопросы (ответы внесены)

5. **Валидация на уровне парсера** — **ответ:** да, отклонять недопустимые формы как не прошедшие валидацию (понятная ошибка).

6. **Верхняя граница числа веток $or / операндов в группе** — **ответ:** да, ограничить **5**; при большем количестве — отклонять запрос как не прошедший валидацию.

7. **Документация** — **ответ:** да, в документации описать: скобки задают группировку, внутри группы только один тип оператора (& или |), JSON в `filter` не поддерживается; лимит 5 на число веток/операндов в группе; недопустимые формы приводят к ошибке валидации.

---

## Анализ сложности

| Аспект | Сложность | Комментарий |
|--------|-----------|-------------|
| **Парсер: введение `\|`** | Средняя | Разбиение по `\|` на глубине 0, затем по `&` на глубине 0; при необходимости «снять» внешние скобки и рекурсия. Уже есть учёт глубины для `&`, нужно симметрично ввести `\|` и порядок (сначала `\|`, потом `&`). |
| **Структура результата** | Средняя | Вместо одного плоского объекта может быть `{ $or: [ branch1, branch2 ] }`, где каждая ветка — либо один объект, либо `{ $and: [ ... ] }`. Рекурсия по скобкам нужна для случаев вида `((a&b)&c)\|d`. |
| **extractMetaFilters и $or** | Высокая | Сейчас meta/regular/member сливаются в один слой. При `$or` нельзя просто объединить: каждая ветка может нести свои meta/regular/member. Нужно либо возвращать «ветки» (массив { regularFilters, metaFilters, memberFilters }), либо ввести слой, который по parsedFilters и entityType строит итоговый MongoDB-запрос (включая вызовы buildMetaQuery/processMemberFilters по веткам). |
| **Контроллеры** | Средняя | Если ввести общий хелпер «построить итоговый query по entityType и parsedFilters», контроллеры только подставляют tenantId и вызывают его; иначе каждый контроллер должен уметь собирать query из веток (regular + meta + member на ветку). |
| **memberFilters при $or** | — | Пока не поддерживаем; фокус на meta-тегах. |
| **Тесты** | Низкая | Юнит-тесты parseFilters для `\|`, комбинаций с `&`, вложенных скобок, при необходимости — на отклонение недопустимых форм; интеграционные тесты на topic/dialog/message с filter с `\|` (meta). |

Итог: основная сложность — согласованная поддержка `$or` в **extractMetaFilters** и сборка запроса по веткам (meta по веткам); member в ветках $or не делаем в первой итерации.

---

## План реализации

### Фаза 1: Парсер (два уровня: `|` и `&`)

1. **Синтаксис зафиксировать**  
   - Разделитель ИЛИ: `|`.  
   - Группировка **только скобками**; при одновременном использовании `&` и `|` скобки обязательны. Внутри одной группы — один тип оператора (`&` или `|`).  
   - Допустимые формы: атом `(field,op,value)`; цепочка И без `|`: `a&b`, `a&b&c&d`; с ИЛИ — только со скобками: `(A&B)|C`, `(A&B)|(C|D)`, `((A&B)&C)|D`, `(A|B|C)&D` (два уровня, в группе не смешиваем `&` и `|`).  
   - Недопустимо: `a&b|c` без скобок; `(a&b|c)` — смешанные операторы в одной группе.  
   - Лимит **5**: число веток в `$or` и число операндов в одной группе — не более 5; при превышении — ошибка валидации.

2. **parseFilters**  
   - Не трогать JSON-ветку (или убрать её отдельно по п.2 IMPROVEMENTS_PLAN).  
   - Нормализация: опционально снять внешние скобки у строки (если вся строка — одна сбалансированная пара скобок).  
   - Разбиение по `|` на **глубине 0** → список OR-операндов. Если на глубине 0 есть и `&`, и `|` без охватывающих скобок — отклонять с ошибкой валидации. Если веток OR или операндов в группе > 5 — отклонять.  
   - Для каждого операнда: разбиение по `&` на **глубине 0** → список AND-операндов.  
   - Каждый операнд: если одна сбалансированная скобка `( ... )`, рекурсивно parseFilters для внутренней подстроки; иначе parseFilter (атом).  
   - Сборка: один AND-операнд → один MongoQuery; несколько AND-операндов → `{ $and: [ ... ] }`; несколько OR-операндов → `{ $or: [ ... ] }`.  
   - Один OR-операнд и один AND-операнд внутри — не оборачивать в `$or`/`$and` (обратная совместимость).

3. **Юнит-тесты queryParser**  
   - `(type,eq,a)|(type,eq,b)` → `{ $or: [ { type: 'a' }, { type: 'b' } ] }`;  
   - `(type,eq,a)&(senderId,eq,c)` → без изменений (как сейчас);  
   - `((type,eq,a)&(senderId,eq,c))|(type,eq,system)` → `{ $or: [ { $and: [ ... ] }, { type: 'system' } ] }`;  
   - `((a,b,c)&(d,e,f)&(g,h,i))|(j,k,l)` → одна ветка $and из трёх атомов, вторая — один атом;  
   - при необходимости: тесты на отклонение `a&b|c` без скобок и `(a&b|c)` (смешанная группа).

### Фаза 2: extractMetaFilters и сборка запроса с meta/member

4. **Обработка $or в extractMetaFilters**  
   - Вариант A: при ключе `$or` возвращать структуру «по веткам», например `{ branches: [ { regularFilters, metaFilters, memberFilters } ], hasOr: true }`.  
   - Вариант B: ввести функцию `buildFilterQuery(tenantId, entityType, parsedFilters)` в queryParser или отдельном модуле: она рекурсивно обрабатывает `$or`/`$and`, для каждой ветки вызывает extractMetaFilters (для одного объекта), buildMetaQuery/processMemberFilters где нужно, и собирает итоговый MongoQuery. Контроллеры тогда вызывают только buildFilterQuery и добавляют tenantId.  
   - Рекомендация: вариант B уменьшает дублирование и централизует работу с meta/member при $or.

5. **extractMetaFilters**  
   - Добавить ветку для `key === '$or'` и `Array.isArray(value)`: для каждого элемента массива рекурсивно вызывать extractMetaFilters, возвращать массив веток (каждая ветка — regularFilters, metaFilters, memberFilters).  
   - Либо не менять возвращаемый тип, а обрабатывать $or только внутри buildFilterQuery (см. п.4).

6. **buildFilterQuery (новый слой)**  
   - Вход: tenantId, entityType ('topic' | 'message' | 'dialog' | …), parsedFilters (результат parseFilters).  
   - Если в parsedFilters нет `$or`: текущая логика (regularFilters + buildMetaQuery + при необходимости processMemberFilters), вернуть один query.  
   - Если есть `$or`: для каждой ветки рекурсивно собрать query (каждая ветка может содержать $and или один объект); для ветки вызвать buildMetaQuery по metaFilters ветки, processMemberFilters по memberFilters ветки; собрать `{ $or: [ query1, query2, ... ] }`.  
   - Учесть, что при memberFilters в ветках нужно решать: объединять ли dialogIds (OR) или строить подзапросы по веткам.

### Фаза 3: Контроллеры и тесты

7. **Подключение в контроллерах**  
   - topicController, messageController, userController, dialogMemberController: заменить ручную связку parseFilters → extractMetaFilters → assign + buildMetaQuery на вызов buildFilterQuery (или эквивалента), затем присвоить query = { tenantId, ...buildFilterQuery(...) }.  
   - dialogController, userDialogController: то же + учёт processMemberFilters (если buildFilterQuery будет возвращать уже «готовый» query с учётом member, иначе оставить текущую схему с dialogId: { $in } поверх buildFilterQuery).

8. **Интеграционные тесты**  
   - Топики: filter `(meta.name,eq,a)|(meta.name,eq,b)` возвращает топики с meta.name a или b.  
   - Сообщения/диалоги: аналогично с type, senderId, meta; при необходимости — с member.

### Фаза 4: Документация и UI

9. **Документация**  
   - API.md, TOPICS_FILTERS.md, при необходимости INTEGRATION.md: описать синтаксис `|`, правило «скобки задают группировку, внутри группы только один тип оператора (& или |)», лимит 5 на число веток/операндов в группе; примеры; недопустимые формы приводят к ошибке валидации. JSON в `filter` не поддерживается.  
   - Упомянуть, что JSON в `filter` не поддерживается (если к этому моменту уже отключён).

10. **UI (controlo-ui)**  
    - В подсказках по фильтрам (кнопка «?») добавить текст: «Условия можно объединять через `&` (И) и `|` (ИЛИ); скобки задают группы, внутри группы только И или только ИЛИ. Пример: (meta.name,eq,a)|(meta.name,eq,b).»

---

## Порядок работ (кратко)

1. Парсер: разбор `|` и вложенных скобок, тесты queryParser.  
2. Решение по формату возврата при $or (ветки vs buildFilterQuery) и реализация extractMetaFilters для $or и/или buildFilterQuery.  
3. Подключение в контроллерах, интеграционные тесты.  
4. Документация и подсказки в UI.

Все ответы на вопросы внесены; план готов к реализации.
