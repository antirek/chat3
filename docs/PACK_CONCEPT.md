# Pack: виртуальный диалог из нескольких диалогов

## Идея

**Pack** — сущность, объединяющая 0, 1 или более диалогов в один «виртуальный» диалог: общий список, счётчики непрочитанного по паку, единая точка входа в UI (папка, канал, проект). Один диалог может входить в **несколько паков**. Привязки к пользователям нет — паки общие на тенанта; при этом каждый пользователь получает список только тех паков, в диалогах которых он состоит (например, `GET /api/users/:userId/packs`).

Сообщения и участники остаются в реальных диалогах; пак — слой агрегации и представления. На паки можно вешать **мета-теги** и использовать их в **фильтрах** запросов.

---

## Текущий контекст (напоминание)

- **Dialog**: минимальная сущность (`dialogId`, `tenantId`, `createdAt`). Участники — в `DialogMember`, мета — в `Meta`, счётчики диалога — в `DialogStats` (topicCount, memberCount, messageCount).
- **UserDialogStats**: `(tenantId, userId, dialogId, unreadCount)` — непрочитанные по диалогу для пользователя.
- **UserStats**: агрегаты по пользователю (dialogCount, unreadDialogsCount и т.д.).
- События: `dialog.create`, `dialog.member.add`, `message.create` и т.д. — всё привязано к одному `dialogId`.
- API списка диалогов пользователя: `GET /api/users/:userId/dialogs` — по `DialogMember` + фильтры + подмешивание UserDialogStats, DialogStats, meta.

---

## Возможности Pack

1. **Единый «входящий» по паку**  
   Вместо N диалогов пользователь видит один пак (например, «Поддержка», «Проект X»). В паке — объединённый список диалогов или общий поток (если решим показывать сообщения из всех диалогов пака).

2. **Счётчик непрочитанного по паку**  
   Один badge: сумма непрочитанных по всем диалогам пака для данного пользователя (или «есть непрочитанное в паке»). Удобно для папок/категорий.

3. **Уведомления и события на уровне пака**  
   Подписка на «что-то изменилось в паке» (новое сообщение в любом диалоге пака, новый участник в любом диалоге) — для пуша, бейджей, ленты.

4. **Фильтрация и навигация**  
   Список диалогов пользователя с группировкой по пакам; фильтр «только диалоги из пака X»; быстрый переход «все диалоги пака».

5. **Права и видимость**  
   Пак как область видимости: «доступ к паку» = доступ к входящим в него диалогам (если политика будет такой). Либо пак — только UI-группировка без отдельной авторизации.

6. **Аналитика и отчёты**  
   Метрики по паку: сумма сообщений, участников, активность по всем диалогам пака.

---

## Счётчики

### Принято

- **UserPackStats** (userId, packId, unreadCount) — нужны: быстрый список «паки с непрочитанным», бейджи по паку для пользователя.
- **PackStats** (packId, messageCount, uniqueMemberCount, sumMemberCount, **uniqueTopicCount**, **sumTopicCount**) — нужны: агрегаты по паку без привязки к пользователю для админки/аналитики. **uniqueMemberCount** — число уникальных userId по всем диалогам пака; **sumMemberCount** — сумма memberCount по диалогам пака; **uniqueTopicCount** — число уникальных topicId по всем диалогам пака; **sumTopicCount** — сумма topicCount по диалогам пака.
- **Обновление**: синхронно в API при операциях или асинхронно воркером по событиям — **на потом** (при проектировании выбрать: консистентность vs нагрузка на API).

### Варианты (для справки)

| Подход | Плюсы | Минусы |
|--------|--------|--------|
| Только на лету | Нет новых коллекций, всегда консистентно с диалогами | Нагрузка при частых запросах списка паков с unread |
| UserPackStats (userId, packId, unreadCount) | Быстрый список «паки с непрочитанным», бейджи | Дублирование логики обновления unread (диалог + пак), рассинхрон при ошибках |
| Гибрид: кэш/материализация с TTL | Баланс скорости и простоты | Сложнее: инвалидация при событиях в диалогах пака |

---

## События

### Принято

- **События управления паками** вводим: `pack.create`, `pack.update`, `pack.dialog.add`, `pack.dialog.remove` — для инвалидации кэшей и подписок на состав паков (подписчики обновляют маппинг dialogId → packIds по этим событиям).
- **События уровня пака** — да: при событии в диалоге дополнительно публикуются события по каждому паку, куда входит диалог (см. раздел «Паки в событиях»).

---

## Модель данных пака (уточнённая)

### Принято

- **Один диалог — несколько паков**: диалог может входить в любое число паков. Хранение состава: отдельная коллекция `PackLink` (packId, dialogId, addedAt — дата добавления). Порядок по умолчанию — от свежих (по addedAt desc). См. ниже.
- **Без привязки к пользователям**: паки общие на тенанта. Видимость для пользователя определяется через участие в диалогах: пользователь видит только паки, в которых хотя бы один диалог содержит его как участника.
- **API списка паков пользователя**: `GET /api/users/:userId/packs` — паки, в чьих диалогах есть данный userId (через DialogMember). Пагинация, фильтры, сортировка — по аналогии с диалогами.
- **Мета-теги на паках**: entityType `pack`, entityId = packId. Те же механизмы, что у dialog/topic: PUT/DELETE meta, фильтры в запросах вида `(meta.category,eq,support)` при списке паков.
- **Создание и редактирование паков** — через API с ключом (как и остальные сущности в системе). Отдельной привязки к пользователю или роли нет: доступ определяется правами API-ключа (tenant, permissions).

### Минимум модели

- **Pack**: `packId`, `tenantId`, `createdAt`, `createdBy`. Состав — в отдельной коллекции **PackLink** (packId, dialogId, **addedAt** — дата добавления диалога в пак). Мета — в коллекции Meta (entityType = `pack`).
- Ограничение по размеру: в паке может быть **0, 1 или более** диалогов (пустой пак, «папка из одного», несколько — все варианты допустимы).

---

## Дефолтный пак

**Вопрос**: должны ли все диалоги по умолчанию входить в один «дефолтный» пак (например, «Все» / «Без категории»), или паки только явные — диалог может вообще не входить ни в один пак?

### Варианты

| Вариант | Описание | Плюсы | Минусы |
|--------|----------|--------|--------|
| **A. Нет дефолтного пака** | Паки только явные. Диалог без паков — просто не в списке ни одного пака. | Простая модель, нет «виртуального» пака на каждый диалог. | В UI «все диалоги» = все диалоги пользователя; «по пакам» — только те, что в паках. Нужно явно различать «все» и «по пакам». |
| **B. Системный дефолтный пак** | Один фиксированный пак (например, `packId = "default"`), в который автоматически входят все диалоги тенанта. | Единообразно: у каждого диалога всегда есть хотя бы один пак; фильтр «пак = default» даёт «все диалоги». | Все диалоги в одном паке — раздувание состава; при 10k диалогах хранить 10k id в паке или генерировать членство на лету («default» = «все dialogId»). |
| **C. Дефолтный пак как «пустая категория»** | При создании диалога его можно опционально добавить в пак «Без категории»; если не добавили ни в какой — он не в паках (как A). Либо «Без категории» — пак с пустым/спец. именем, куда попадают диалоги, не добавленные ни в один другой пак (вычисляется на лету при запросе). | Баланс: есть понятие «без категории» без хранения всех id в одном паке. | Логика «без категории» чуть сложнее (отдельный кейс в API/UI). |

**Принято**: вариант **A** — паки только явные; диалог может не входить ни в один пак. В UI «все диалоги» = все диалоги пользователя; «по пакам» — только те, что в паках.

---

## Паки в событиях: как не раздувать payload

**Проблема**: при событии в диалоге (например, `message.create`) подписчик может хотеть знать «в каких паках этот диалог». Если диалог в 10–100 паках, класть в каждое событие массив `packIds: ["pck_1", "pck_2", ...]` — лишние данные, дублирование, рост размера сообщений в очереди.

### Варианты

| Вариант | Описание | Плюсы | Минусы |
|--------|----------|--------|--------|
| **1. Не фиксировать паки в событиях** | События диалога как сейчас: только `dialogId` (и остальные поля). Клиент/воркер при необходимости сам запрашивает «диалог в каких паках» (GET …/packs?filter=… или отдельный справочник dialogId → packIds). | Нет роста payload, события остаются маленькими. | Подписчику нужен дополнительный запрос или локальный кэш «dialogId → packIds»; кэш нужно поддерживать при изменении состава паков. |
| **2. Отдельные события уровня пака** | Для каждого события в диалоге (message.create и т.д.) воркер или API дополнительно публикует N событий типа `pack.activity` (по одному на каждый пак, куда входит диалог), с минимальным payload (packId, dialogId, eventType, ссылка на исходное событие). Подписчик на паки подписывается на `pack.activity.*` и не получает packIds в исходном событии. | Исходное событие без packIds; кто интересуется паками — подписан на события пака. | Много сообщений в очереди (1 message.create → N pack.activity при N паках); подписчик пака получает N уведомлений на одно действие. |
| **3. Лёгкая ссылка «есть паки»** | В событие диалога добавлять один флаг или число: `inPacks: true` или `packCount: 5`, без перечисления id. Подписчик, которому нужны конкретные packIds, сам разрешает по dialogId. | Минимальный рост payload; можно фильтровать «события только из диалогов, входящих хотя бы в один пак». | Конкретные packIds всё равно нужны отдельным запросом/кэшем. |
| **4. Отдельный канал «обновления членства в паках»** | События диалога без изменений. При изменении состава паков (dialog добавили/убрали из пака) публикуется событие `pack.updated` (packId, dialogId, added/removed). Подписчики держат локальный маппинг dialogId → packIds и обновляют его по этим событиям. Для «события в диалоге» подписчик сам смотрит по своему маппингу, в каких паках диалог. | События диалога не раздуваются; состав паков разрешается один раз и поддерживается инкрементально. | Нужна подписка на `pack.*` и поддержка кэша на стороне подписчика. |

**Принято**: **события уровня пака будут** (вариант 2). Для каждого события в диалоге (message.create и т.д.) дополнительно публикуются события уровня пака (по одному на каждый пак, куда входит диалог) — подписчик на пак получает уведомления «в паке X произошло действие». Исходное событие диалога без packIds не раздувается; события пака — отдельный канал с минимальным payload (packId, dialogId, eventType, ссылка на исходное событие).

---

## API (уточнённое)

- **Список паков пользователя**: `GET /api/users/:userId/packs` — паки, в чьих диалогах пользователь участвует. Query: `page`, `limit`, `filter`, `sort`. Фильтры по полям пака и по **meta** (например, `(meta.category,eq,support)`). Ответ: список паков, в каждом — состав dialogIds и/или счётчики (если введём).
- **Один пак**: `GET /api/users/:userId/packs/:packId` или `GET /api/packs/:packId` (с проверкой доступа: пользователь должен быть участником хотя бы одного диалога пака).
- **Список диалогов пользователя**: поле `packIds` в ответ не включать. Отдельный endpoint — **список паков для диалога**: GET /api/users/:userId/dialogs/:dialogId/packs или GET /api/dialogs/:dialogId/packs (список паков, в которые входит данный диалог).
- **Сообщения**: остаётся «сообщения одного диалога» (`GET /api/dialogs/:dialogId/messages`). **Объединённый поток по паку** — нужен: `GET /api/packs/:packId/messages` (или `GET /api/users/:userId/packs/:packId/messages`) — все сообщения из диалогов пака в одном потоке с пагинацией и сортировкой по времени (детали пагинации и производительности — при проектировании).

---

## Соображения и риски

1. **Производительность**  
   Если счётчики по паку считаются на лету — при большом числе диалогов в паке и частых запросах нужны индексы и возможно кэш. Если введём материализованные счётчики — нужна надёжная синхронизация с событиями диалогов.

2. **Права**  
   Просмотр пака должен учитывать: пользователь имеет доступ только к тем диалогам пака, где он участник. Не показывать в паке диалоги, где пользователя нет.

3. **Консистентность**  
   При удалении диалога или удалении пользователя из диалога — нужно ли автоматически убирать диалог из пака / пересчитывать состав пака. При удалении пака — только удалить сущность пака, диалоги остаются.

4. **Обратная совместиость**  
   Текущий API «диалоги пользователя» не обязан сразу возвращать паки; можно ввести опциональный query-параметр `includePacks=true` и поле `packIds` у диалогов, либо отдельные эндпоинты для паков.

5. **Виртуальность**  
   Пак не заменяет диалог: создание сообщения, участники, топики — по-прежнему в рамках диалога. Пак — только способ группировки и агрегации для отображения и уведомлений.

6. **Размер событий**  
   Не дублировать в каждое событие диалога список packIds при большом числе паков на диалог — см. раздел «Паки в событиях».

---

## Вопросы для решения перед проектированием

**Уже зафиксировано**: один диалог — в нескольких паках; без привязки к пользователям; список паков пользователя — `GET /api/users/:userId/packs`; мета на паках и фильтры по meta; **дефолтный пак — вариант A**; **состав пака — отдельная коллекция** PackLink (packId, dialogId, addedAt); уникальность (packId, dialogId); при повторном добавлении диалога в пак — идемпотентный успех без смены addedAt; порядок диалогов в паке по умолчанию — от свежих (addedAt desc); **счётчики** — UserPackStats и PackStats (uniqueMemberCount, sumMemberCount, uniqueTopicCount, sumTopicCount в PackStats; синхронное или асинхронное обновление — решить при проектировании); **события управления паками** — да; **события уровня пака** — да; **единый поток сообщений пака** — да; **создание/редактирование паков** — через API с ключом; **каскад**: при удалении диалога из системы — удалять записи PackLink; при удалении пака — каскадно удалять PackLink, PackStats, UserPackStats по packId; **пустой пак**: пак с 0 диалогов допустим, пак не удалять и не архивировать при удалении последнего диалога; **размер пака**: допустимы 0, 1 или более диалогов (ограничения на минимум нет); **tenant**: пак и все диалоги в паке — один tenantId; при добавлении диалога в пак проверять совпадение tenantId; **формат packId**: pck_[a-z0-9]{20}, генерация при создании пака; **packIds в списке диалогов** не возвращать; отдельный endpoint для списка паков диалога (GET .../dialogs/:dialogId/packs или .../users/:userId/dialogs/:dialogId/packs); **доступ к пустому паку**: в админке пак по packId можно увидеть и удалить; в списке пользователя пустой пак не возвращается.

**Остаётся решить** (на этапе проектирования):

- Синхронное или асинхронное обновление UserPackStats и PackStats.
- Детали пагинации и индексов для `GET /api/packs/:packId/messages`.

Все ключевые концептуальные решения приняты; далее — детальная модель данных, API и план внедрения (модель пака + PackLink + meta + фильтры → счётчики → события и поток сообщений пака).

---

## Слабые места и риски концепции

Ниже — узкие места, неоднозначности и риски, которые стоит учесть при проектировании и реализации.

### 1. Нагрузка на очередь при событиях уровня пака

**Принято**: при событии в диалоге публикуется по одному событию уровня пака на каждый пак, куда входит диалог (вариант 2).

**Риск**: один `message.create` в диалоге, который входит в 50 паков → 50 сообщений в RabbitMQ. При активном чате и большом числе паков на диалог нагрузка на очередь и воркеры растёт линейно. Подписчик, следящий за несколькими паками, может получить много дубликатов по смыслу (одно и то же сообщение в N паках) — нужна дедупликация по исходному `eventId`, если показываем одно уведомление на действие.

**Рекомендация**: на этапе проектирования заложить лимиты (макс. число паков на диалог?) или приоритизацию/батчинг событий пака; подписчикам — идемпотентная обработка по `eventId`.

### 2. Семантика агрегатов PackStats

**PackStats**: messageCount, **uniqueMemberCount**, **sumMemberCount**, **uniqueTopicCount**, **sumTopicCount** по паку.

**Принято**:  
- **uniqueMemberCount** — число уникальных userId по всем диалогам пака (один пользователь, участник нескольких диалогов пака, считается один раз).  
- **sumMemberCount** — сумма memberCount по диалогам пака («всего участников-мест», для аналитики нагрузки).  
- **uniqueTopicCount** — число уникальных topicId по всем диалогам пака (один топик считается один раз; при отвязке топика от диалога семантика сохраняется).  
- **sumTopicCount** — сумма topicCount по диалогам пака (сумма DialogStats.topicCount по диалогам пака).

### 3. Видимость пака vs состав пака

**Принято**: пользователь видит только паки, в которых участвует хотя бы в одном диалоге; в паке показывать только диалоги, где он участник («не показывать диалоги, где пользователя нет»).

**Неоднозначность**: PackStats (messageCount, uniqueMemberCount, sumMemberCount, uniqueTopicCount, sumTopicCount) считаются по **всему** паку или только по диалогам, доступным текущему пользователю? Если по всему паку — в UI пользователь видит «пак: 100 сообщений», но сам имеет доступ к части диалогов (например, 20 сообщений). Если по «своим» диалогам — то счётчики зависят от userId, и PackStats не могут быть одной записью на пак без привязки к пользователю.

**Рекомендация**: разделить: **PackStats** — агрегаты по всему паку (messageCount, uniqueMemberCount, sumMemberCount, uniqueTopicCount, sumTopicCount — для админки/аналитики); для пользователя в API списка паков возвращать **UserPackStats** (unreadCount) и опционально «доступный» messageCount/uniqueMemberCount по диалогам пака, где он участник (считаться на лету или кэш).

### 4. Авторизация и семантика userId в path

**API**: `GET /api/users/:userId/packs` — «паки, в диалогах которых участвует userId».

**Вопрос**: в системе доступ по API-ключу (tenant, permissions). Откуда берётся `userId` в path — это «текущий пользователь» (идентичность из ключа) или произвольный userId (например, админ запрашивает паки другого пользователя)? Если произвольный — нужна явная политика: какой ключ может запрашивать паки для какого userId (только себя / только свой tenant / админ по любому userId в tenant).

**Рекомендация**: зафиксировать в API: либо `userId` в path всегда = идентичность ключа (тогда path можно упростить до `GET /api/me/packs`), либо явно описать, кто может указывать чужой userId.

### 5. Единый поток сообщений пака: производительность и ответ

**Принято**: `GET /api/packs/:packId/messages` — все сообщения диалогов пака в одном потоке.

**Риски**:  
- Запрос по сути — объединение N диалогов (по PackLink), сортировка по времени, пагинация. При большом числе диалогов в паке и большом объёме сообщений агрегация тяжёлая; нужны индексы (например, по (dialogId, createdAt)) и стратегия пагинации (курсор по (createdAt, messageId)).  
- В ответе каждое сообщение должно нести **dialogId** (и при необходимости topicId), иначе клиент не знает, в какой диалог вести при клике. Формат ответа и контракт — зафиксировать при проектировании.

**Рекомендация**: на этапе проектирования выбрать стратегию запроса (агрегация по Message + filter by dialogId in [...], или отдельный материал. представление) и формат элемента (message + dialogId [+ topicId]).

### 6. Каскад при удалении диалога и пустые паки

**Принято**:  
- При **удалении диалога из системы** — автоматически удалять записи PackLink с этим dialogId (каскад), чтобы не оставались ссылки на несуществующий диалог.  
- **Пак с 0 диалогов допустим**: при удалении последнего диалога из пака (pack.dialog.remove) пак не удалять и не архивировать. Пока в паке есть хотя бы один диалог — пак не удалять; пак без диалогов — валидное состояние (пустой пак).

### 7. Размер пака: 0, 1 или более диалогов

**Принято**: пак может содержать **0, 1 или более** диалогов. Допустимы: пустой пак (0), пак из одного диалога («папка из одного»), пак из нескольких диалогов. Ограничения на минимальное число диалогов нет.

### 8. Имя коллекции состава пака

**Принято**: использовать **PackLink** (packId, dialogId, addedAt) — связка «диалог входит в пак» с датой добавления. Имя явно отличается от **DialogMember** (userId, dialogId — участник-пользователь диалога), путаницы «member = пользователь» нет. Порядок по умолчанию — по addedAt desc (от свежих).

### 9. Порядок диалогов в паке

**Принято**: в **PackLink** сохранять **дату добавления** (addedAt) диалога в пак. По умолчанию диалоги в паке отображать **от свежих** (сортировка по addedAt desc — недавно добавленные первыми).

### 10. Tenant при добавлении диалога в пак

**Принято**: пак и все его диалоги — в рамках одного **tenantId**. При добавлении диалога в пак (pack.dialog.add) проверять: tenantId диалога и tenantId пака совпадают; иначе — отказ.

---

## Повторный анализ: тонкие моменты и открытые вопросы

Ниже — дополнительные слабые места, краевые случаи и вопросы для уточнения при проектировании.

### A. Уникальность и идемпотентность PackLink

**Принято**: в коллекции PackLink действует **уникальность (packId, dialogId)** — один диалог в паке только один раз. При повторном вызове «добавить диалог в пак» (диалог уже в паке) — **идемпотентный успех без смены addedAt**: возвращать успех, запись не менять, addedAt остаётся прежним.

### B. Каскад при удалении пака

**Принято**: при **удалении пака** (pack.delete или аналог) каскадно удалять:
- все записи **PackLink** с этим packId;
- записи **PackStats** для этого packId;
- записи **UserPackStats** для этого packId.

Иначе останутся «сиротские» записи по несуществующему паку.

### C. UserPackStats при «уходе» пользователя из пака

**Тонкий момент**: пользователь видит пак, только если участвует хотя бы в одном диалоге этого пака. При удалении из пака последнего диалога, в котором был пользователь (или удалении пользователя из этого диалога), пользователь фактически «выбыл» из пака — пак больше не должен отображаться в его списке. Запись UserPackStats (userId, packId, unreadCount) при этом может остаться. При следующем запросе GET /api/users/:userId/packs пак не вернётся (в паке нет диалогов с его участием), но запись в UserPackStats — «мусор».

**Вопрос**: при удалении диалога из пака или удалении пользователя из диалога — нужно ли помечать/удалять записи UserPackStats для пар (userId, packId), для которых в паке больше не осталось диалогов с участием этого пользователя? Или считать UserPackStats только для текущего состава «пользователь видит пак» и не хранить записи для «пустых для пользователя» паков?

### D. Имена типов событий уровня пака

**Принято**: при событии в диалоге публикуются события уровня пака. Не зафиксировано **точное имя типа** события. От имени зависят роутинг в RabbitMQ и подписки воркеров/клиентов.

**Варианты**:

| Вариант | Имя типа события | Payload (помимо packId, dialogId, ссылки на исходное событие) | Плюсы | Минусы |
|--------|-------------------|-----------------------------------------------------------------|--------|--------|
| **1. Зеркало типа** | `pack.{eventType}` — подстановка исходного типа, напр. `pack.message.created`, `pack.dialog.member.add` | — | Подписчик может фильтровать по типу (только message.created, только member.add). Роутинг по типу: `pack.message.created.{tenantId}`. | Много типов событий в схеме RabbitMQ; при добавлении нового типа диалога нужно добавлять тип пака. |
| **2. Единый тип** | `pack.activity` (один тип на все действия в паке) | `sourceEventType: "message.create"`, при необходимости entityType, entityId | Один тип события, одна подписка на «любая активность в паке». Простая схема. | Подписчик сам разбирает sourceEventType; фильтрация по типу действия — в коде клиента/воркера. |
| **3. Категория + тип** | `pack.{category}.{action}` — напр. `pack.message.created`, `pack.member.add` (без префикса dialog.) | — | Баланс: несколько типов (message.*, member.*), но не полное зеркало. Меньше типов, чем в 1. | Всё равно несколько типов; договориться о наборе категорий. |
| **4. Префикс + исходный eventType** | `pack.{eventType}` — напр. `pack.message.create`, `pack.dialog.member.add` | — | Единый префикс `pack`; подстановка исходного eventType. | — |

**Вопрос**: выбрать схему именования (1–4 или гибрид) и зафиксировать в API/документации событий.

### E. Формат packId

**Принято**: формат **packId** — `pck_[a-z0-9]{20}` (аналогично dlg_xxx, topic_xxx). Генерация при создании пака (в API или в модели). Уникальность в рамках тенанта (или глобально — как у dialogId, topicId).

### F. Порядок паков в списке пользователя

**Вопрос**: порядок по умолчанию для GET /api/users/:userId/packs — по чему? По createdAt пака, по последней активности в паке (например, max lastMessageAt по диалогам пака), по количеству непрочитанных (unreadCount desc), по имени (meta)? Сейчас задан порядок диалогов внутри пака (addedAt desc), но не порядок самих паков в списке.

**Вопрос**: зафиксировать сортировку по умолчанию для списка паков пользователя (и доступные поля для sort).

### G. Список паков для диалога

**Принято**: в ответ GET /api/users/:userId/dialogs поле **packIds не включать**. Отдельный **endpoint для получения списка паков диалога** — напр. GET /api/users/:userId/dialogs/:dialogId/packs или GET /api/dialogs/:dialogId/packs (с проверкой доступа). Клиент при необходимости запрашивает паки по каждому диалогу; payload списка диалогов не раздувается.

### H. Удаление пака: есть ли операция

**Вопрос**: предусмотрена ли операция удаления пака (DELETE /api/packs/:packId или аналог)? Если да — см. каскад (п. B). Если паки только создают и редактируют (добавляют/убирают диалоги), но не удаляют — зафиксировать явно.

### I. Доступ к пустому паку

**Принято**: пак с 0 диалогов в списке пользователя GET /api/users/:userId/packs не попадёт (нет диалогов с его участием). По прямому **packId** (GET /api/packs/:packId или аналог): в **админке** такой пак можно **увидеть и удалить** — ключ с правами админки/управления может открыть любой пак по id (в т.ч. пустой), получить состав (пустой) и при необходимости удалить. Для обычного пользовательского контекста доступ к паку — только если он участвует хотя бы в одном диалоге пака; пустой пак по packId для него — 403 или не возвращается в списке.

### J. Топики в PackStats: uniqueTopicCount и sumTopicCount

**Принято**: в PackStats два поля по топикам — **uniqueTopicCount** и **sumTopicCount**.  
- **uniqueTopicCount** — число уникальных topicId по всем диалогам пака (один топик считается один раз; при отвязке топика от диалога семантика сохраняется).  
- **sumTopicCount** — сумма DialogStats.topicCount по диалогам пака («всего топиков-мест» по диалогам пака, для аналитики).
