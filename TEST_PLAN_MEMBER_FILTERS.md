# План тестирования фильтрации по участникам диалогов

## 1. Базовые тесты операторов фильтрации

### 1.1. Оператор `in` (OR логика - хотя бы один из участников)

**Тест 1.1.1: Фильтр с одним участником**
- **Запрос**: `GET /api/users/{userId}/dialogs?filter=(member,in,[alice])`
- **Ожидаемый результат**: Все диалоги пользователя, где присутствует `alice`
- **Проверки**:
  - Все возвращенные диалоги содержат текущего пользователя
  - Все возвращенные диалоги содержат `alice`
  - Диалоги без `alice` не возвращаются

**Тест 1.1.2: Фильтр с несколькими участниками (OR)**
- **Запрос**: `GET /api/users/{userId}/dialogs?filter=(member,in,[alice,bob])`
- **Ожидаемый результат**: Все диалоги, где присутствует хотя бы один из `alice` или `bob`
- **Проверки**:
  - Все возвращенные диалоги содержат текущего пользователя
  - Каждый диалог содержит хотя бы одного из `alice` или `bob`
  - Диалоги, где нет ни `alice`, ни `bob`, не возвращаются

**Тест 1.1.3: Фильтр с несуществующим участником**
- **Запрос**: `GET /api/users/{userId}/dialogs?filter=(member,in,[nonexistent])`
- **Ожидаемый результат**: Пустой массив `[]`
- **Проверки**:
  - `pagination.total = 0`
  - `data = []`

### 1.2. Оператор `all` (AND логика - все указанные участники)

**Тест 1.2.1: Фильтр со всеми участниками (2 участника)**
- **Запрос**: `GET /api/users/{userId}/dialogs?filter=(member,all,[alice,bob])`
- **Ожидаемый результат**: Все диалоги, где присутствуют И `alice` И `bob`
- **Проверки**:
  - Все возвращенные диалоги содержат текущего пользователя
  - Все возвращенные диалоги содержат И `alice` И `bob`
  - Диалоги, где есть только один из участников, не возвращаются

**Тест 1.2.2: Фильтр со всеми участниками (3+ участника)**
- **Запрос**: `GET /api/users/{userId}/dialogs?filter=(member,all,[alice,bob,eve])`
- **Ожидаемый результат**: Все диалоги, где присутствуют все три участника
- **Проверки**:
  - Все возвращенные диалоги содержат текущего пользователя
  - Все возвращенные диалоги содержат всех трех участников

**Тест 1.2.3: Фильтр `all` с участником, которого нет ни в одном диалоге**
- **Запрос**: `GET /api/users/{userId}/dialogs?filter=(member,all,[alice,nonexistent])`
- **Ожидаемый результат**: Пустой массив `[]`

### 1.3. Оператор `ne` (исключение одного участника)

**Тест 1.3.1: Исключение одного участника**
- **Запрос**: `GET /api/users/{userId}/dialogs?filter=(member,ne,alice)`
- **Ожидаемый результат**: Все диалоги пользователя, где НЕТ `alice`
- **Проверки**:
  - Все возвращенные диалоги содержат текущего пользователя
  - Ни один из возвращенных диалогов не содержит `alice`
  - Диалоги с `alice` не возвращаются

**Тест 1.3.2: Исключение несуществующего участника**
- **Запрос**: `GET /api/users/{userId}/dialogs?filter=(member,ne,nonexistent)`
- **Ожидаемый результат**: Все диалоги пользователя (как без фильтра)
- **Проверки**:
  - Результат идентичен запросу без фильтра

### 1.4. Оператор `nin` (исключение нескольких участников)

**Тест 1.4.1: Исключение нескольких участников**
- **Запрос**: `GET /api/users/{userId}/dialogs?filter=(member,nin,[alice,bob])`
- **Ожидаемый результат**: Все диалоги, где НЕТ ни `alice`, ни `bob`
- **Проверки**:
  - Все возвращенные диалоги содержат текущего пользователя
  - Ни один из возвращенных диалогов не содержит `alice` или `bob`
  - Диалоги с `alice` или `bob` не возвращаются

**Тест 1.4.2: Исключение всех участников кроме текущего пользователя**
- **Запрос**: `GET /api/users/carl/dialogs?filter=(member,nin,[alice,bob,marta,eve,...])`
- **Ожидаемый результат**: Только диалоги, где есть только текущий пользователь (или другие неисключенные участники)

## 2. Комбинации фильтров

### 2.1. Комбинация фильтров по участникам с другими фильтрами

**Тест 2.1.1: Фильтр по участникам + фильтр по meta**
- **Запрос**: `GET /api/users/{userId}/dialogs?filter=(member,in,[alice])&(meta.channelType,eq,whatsapp)`
- **Ожидаемый результат**: Диалоги с `alice` И типом канала `whatsapp`
- **Проверки**:
  - Все диалоги содержат `alice`
  - Все диалоги имеют `meta.channelType = whatsapp`

**Тест 2.1.2: Фильтр по участникам + фильтр по unreadCount**
- **Запрос**: `GET /api/users/{userId}/dialogs?filter=(member,in,[alice])&(unreadCount,gt,0)`
- **Ожидаемый результат**: Диалоги с `alice` И с непрочитанными сообщениями
- **Проверки**:
  - Все диалоги содержат `alice`
  - У всех диалогов `context.unreadCount > 0`

**Тест 2.1.3: Комплексная комбинация фильтров**
- **Запрос**: `GET /api/users/{userId}/dialogs?filter=(member,all,[alice,bob])&(meta.type,eq,internal)&(unreadCount,gte,1)`
- **Ожидаемый результат**: Диалоги со всеми участниками `alice` и `bob`, внутренние, с непрочитанными сообщениями
- **Проверки**:
  - Все условия выполняются одновременно (AND логика)

### 2.2. Комбинация разных операторов фильтров по участникам

**Тест 2.2.1: `all` + `ne` (невозможная комбинация через один фильтр, но можно через $and)**
- **Примечание**: Нужно проверить, поддерживается ли JSON-формат с `$and`

**Тест 2.2.2: Множественные фильтры `in` через `&`**
- **Запрос**: `GET /api/users/{userId}/dialogs?filter=(member,in,[alice])&(member,in,[bob])`
- **Ожидаемый результат**: Диалоги, где есть И `alice` И `bob` (пересечение, как `all`)
- **Проверки**: Должно работать как `(member,all,[alice,bob])`

## 3. Граничные случаи и валидация

### 3.1. Пустые значения и некорректный формат

**Тест 3.1.1: Пустой массив участников**
- **Запрос**: `GET /api/users/{userId}/dialogs?filter=(member,in,[])`
- **Ожидаемый результат**: 400 Bad Request или пустой результат

**Тест 3.1.2: Некорректный формат фильтра**
- **Запрос**: `GET /api/users/{userId}/dialogs?filter=(member,in,alice)` (без скобок для массива)
- **Ожидаемый результат**: 400 Bad Request с описанием ошибки

**Тест 3.1.3: Несуществующий оператор**
- **Запрос**: `GET /api/users/{userId}/dialogs?filter=(member,unknown,[alice])`
- **Ожидаемый результат**: 400 Bad Request с описанием поддерживаемых операторов

### 3.2. Большие объемы данных

**Тест 3.2.1: Фильтр с большим количеством участников в `in`**
- **Запрос**: `GET /api/users/{userId}/dialogs?filter=(member,in,[user1,user2,...,user100])`
- **Ожидаемый результат**: Корректная работа, разумное время ответа
- **Проверки**:
  - Время ответа < 2 секунд
  - Результат корректный

**Тест 3.2.2: Фильтр по участникам в диалоге с большим количеством участников**
- **Сценарий**: Диалог с 100+ участниками, фильтр по одному из них
- **Проверки**: Корректная работа, разумное время ответа

### 3.3. Специальные символы и кодирование

**Тест 3.3.1: Участник с специальными символами в ID**
- **Запрос**: `GET /api/users/{userId}/dialogs?filter=(member,in,[user_with-special_chars.123])`
- **Ожидаемый результат**: Корректная обработка специальных символов

**Тест 3.3.2: URL-кодирование фильтра**
- **Запрос**: `GET /api/users/{userId}/dialogs?filter=%28member%2Cin%2C%5Balice%2Cbob%5D%29`
- **Ожидаемый результат**: Корректное декодирование и применение фильтра

## 4. Пагинация и сортировка

### 4.1. Пагинация с фильтрами по участникам

**Тест 4.1.1: Первая страница**
- **Запрос**: `GET /api/users/{userId}/dialogs?page=1&limit=10&filter=(member,in,[alice])`
- **Проверки**:
  - Возвращается не более 10 диалогов
  - `pagination.page = 1`
  - `pagination.limit = 10`
  - `pagination.total` корректный

**Тест 4.1.2: Последняя страница**
- **Запрос**: `GET /api/users/{userId}/dialogs?page=3&limit=10&filter=(member,in,[alice])`
- **Проверки**:
  - Возвращается корректное количество диалогов (если есть)
  - `pagination.pages` корректный

**Тест 4.1.3: Страница за пределами доступных данных**
- **Запрос**: `GET /api/users/{userId}/dialogs?page=1000&limit=10&filter=(member,in,[alice])`
- **Ожидаемый результат**: Пустой массив `[]`, `pagination.total` корректный

### 4.2. Сортировка с фильтрами по участникам

**Тест 4.2.1: Сортировка по unreadCount с фильтром по участникам**
- **Запрос**: `GET /api/users/{userId}/dialogs?filter=(member,in,[alice])&sort=(unreadCount,desc)`
- **Проверки**:
  - Диалоги отсортированы по `unreadCount` по убыванию
  - Фильтр по участникам применяется корректно

**Тест 4.2.2: Сортировка по lastInteractionAt с фильтром по участникам**
- **Запрос**: `GET /api/users/{userId}/dialogs?filter=(member,in,[alice])&sort=(lastInteractionAt,desc)`
- **Проверки**:
  - Диалоги отсортированы по `lastInteractionAt` по убыванию
  - Фильтр по участникам применяется корректно

## 5. Производительность

### 5.1. Время выполнения запросов

**Тест 5.1.1: Простой фильтр `in` с одним участником**
- **Метрики**: Время ответа < 500ms для 100 диалогов

**Тест 5.1.2: Фильтр `all` с несколькими участниками**
- **Метрики**: Время ответа < 1s для 100 диалогов

**Тест 5.1.3: Фильтр `nin` с исключением нескольких участников**
- **Метрики**: Время ответа < 1s для 100 диалогов

### 5.2. Масштабируемость

**Тест 5.2.1: Фильтр по участникам при большом количестве диалогов**
- **Сценарий**: Пользователь в 1000+ диалогах, фильтр по участникам
- **Метрики**: Время ответа < 2s, использование индексов

**Тест 5.2.2: Фильтр `all` при большом количестве участников в диалогах**
- **Сценарий**: Диалоги с 50+ участниками, фильтр `all` для 5 участников
- **Метрики**: Время ответа < 2s

## 6. Интеграционные тесты

### 6.1. Взаимодействие с другими эндпоинтами

**Тест 6.1.1: Получение сообщений диалога после фильтрации**
- **Сценарий**: 
  1. Фильтр по участникам возвращает диалоги
  2. Получение сообщений для первого диалога
- **Проверки**: Сообщения загружаются корректно

**Тест 6.1.2: Добавление нового участника и применение фильтра**
- **Сценарий**:
  1. Применить фильтр `(member,in,[newUser])`
  2. Добавить `newUser` в диалог
  3. Применить фильтр снова
- **Проверки**: Новый диалог появляется в результатах

**Тест 6.1.3: Удаление участника и применение фильтра**
- **Сценарий**:
  1. Применить фильтр `(member,in,[userToRemove])`
  2. Удалить `userToRemove` из диалога
  3. Применить фильтр снова
- **Проверки**: Диалог исчезает из результатов

### 6.2. Консистентность данных

**Тест 6.2.1: Согласованность `membersCount` с фильтрами**
- **Проверки**: `membersCount` в ответе соответствует реальному количеству участников

**Тест 6.2.2: Согласованность `context` с фильтрами**
- **Проверки**: `context.userId` всегда соответствует запрошенному пользователю

## 7. Тесты безопасности и авторизации

### 7.1. Доступ к данным

**Тест 7.1.1: Фильтр по участникам для несуществующего пользователя**
- **Запрос**: `GET /api/users/nonexistent/dialogs?filter=(member,in,[alice])`
- **Ожидаемый результат**: 404 Not Found или пустой массив

**Тест 7.1.2: Фильтр по участникам для пользователя из другого tenant**
- **Запрос**: `GET /api/users/{userId}/dialogs?filter=(member,in,[alice])` с другим `X-Tenant-Id`
- **Ожидаемый результат**: Пустой массив (нет доступа к данным другого tenant)

### 7.2. Валидация входных данных

**Тест 7.2.1: SQL injection попытка в фильтре**
- **Запрос**: `GET /api/users/{userId}/dialogs?filter=(member,in,['); DROP TABLE dialogs; --])`
- **Ожидаемый результат**: 400 Bad Request, данные не повреждены

**Тест 7.2.2: NoSQL injection попытка в фильтре**
- **Запрос**: `GET /api/users/{userId}/dialogs?filter=(member,in,[{$ne:null}])`
- **Ожидаемый результат**: 400 Bad Request или корректная обработка

## 8. Регрессионные тесты

### 8.1. Сохранение обратной совместимости

**Тест 8.1.1: Запрос без фильтра по участникам**
- **Запрос**: `GET /api/users/{userId}/dialogs`
- **Проверки**: Результат идентичен версии до добавления фильтров по участникам

**Тест 8.1.2: Запрос с другими фильтрами (без фильтра по участникам)**
- **Запрос**: `GET /api/users/{userId}/dialogs?filter=(meta.type,eq,internal)`
- **Проверки**: Фильтры работают как раньше

## 9. Структура тестов

### 9.1. Юнит-тесты (unit tests)
- **Файл**: `tests/unit/utils/queryParser.test.js`
- **Покрытие**: 
  - Парсинг фильтров `(member,in,[...])`
  - Парсинг фильтров `(member,all,[...])`
  - Парсинг фильтров `(member,ne,...)`
  - Парсинг фильтров `(member,nin,[...])`
  - Извлечение `memberFilters` из общего фильтра

### 9.2. Интеграционные тесты (integration tests)
- **Файл**: `tests/integration/userDialogs.test.js`
- **Покрытие**:
  - Все базовые тесты операторов (раздел 1)
  - Комбинации фильтров (раздел 2)
  - Пагинация и сортировка (раздел 4)

### 9.3. E2E тесты (end-to-end tests)
- **Файл**: `tests/e2e/userDialogs.e2e.test.js`
- **Покрытие**:
  - Полный сценарий использования фильтров
  - Взаимодействие с UI
  - Производительность (раздел 5)

### 9.4. Нагрузочные тесты (load tests)
- **Файл**: `tests/load/memberFilters.load.test.js`
- **Покрытие**:
  - Тесты производительности (раздел 5)
  - Масштабируемость (раздел 5.2)

## 10. Инструменты для тестирования

### 10.1. Фреймворки
- **Юнит-тесты**: Jest или Mocha + Chai
- **Интеграционные тесты**: Jest + Supertest
- **E2E тесты**: Playwright или Cypress
- **Нагрузочные тесты**: Artillery или k6

### 10.2. Тестовые данные
- **Фикстуры**: Создание тестовых пользователей, диалогов, участников
- **Seed скрипт**: `tests/fixtures/seedMemberFilters.js`
- **Очистка**: Автоматическая очистка тестовых данных после тестов

### 10.3. Моки и стабы
- **Моки MongoDB**: Использование `mongodb-memory-server` для изоляции тестов
- **Моки внешних сервисов**: RabbitMQ, если используется

## 11. Критерии приемки

### 11.1. Функциональность
- ✅ Все операторы (`in`, `all`, `ne`, `nin`) работают корректно
- ✅ Комбинации фильтров работают корректно
- ✅ Пагинация и сортировка работают с фильтрами
- ✅ Валидация входных данных работает корректно

### 11.2. Производительность
- ✅ Время ответа < 1s для большинства запросов
- ✅ Время ответа < 2s для сложных запросов
- ✅ Использование индексов MongoDB

### 11.3. Качество кода
- ✅ Покрытие тестами > 80%
- ✅ Все тесты проходят
- ✅ Нет утечек памяти
- ✅ Корректная обработка ошибок

## 12. Приоритеты тестирования

### Высокий приоритет (P0)
- Базовые тесты операторов (раздел 1.1, 1.2)
- Граничные случаи (раздел 3.1)
- Безопасность (раздел 7)

### Средний приоритет (P1)
- Комбинации фильтров (раздел 2)
- Пагинация и сортировка (раздел 4)
- Интеграционные тесты (раздел 6)

### Низкий приоритет (P2)
- Производительность (раздел 5)
- Нагрузочные тесты (раздел 9.4)
- Регрессионные тесты (раздел 8)

