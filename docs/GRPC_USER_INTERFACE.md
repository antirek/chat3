# Анализ gRPC интерфейса для пользователя

## Обзор

Документ описывает архитектурные соображения для построения gRPC интерфейса, который позволит пользователям:
- Получать данные по своим диалогам
- Получать данные по сообщениям
- Отправлять сообщения
- Получать updates по своим событиям в реальном времени

## Архитектура

### Компоненты

```
┌─────────────────┐
│   gRPC Client   │ (Пользователь)
│   (TypeScript/  │
│    Go/Python)   │
└────────┬────────┘
         │ gRPC
         │
┌────────▼────────────────────────┐
│   gRPC Server (User Gateway)    │
│                                 │
│  - Аутентификация пользователя  │
│  - Обработка gRPC запросов      │
│  - Проксирование к tenant-api   │
│  - Подписка на RabbitMQ updates │
│  - Stream updates клиентам      │
└────────┬────────────────────────┘
         │
    ┌────┴────┬─────────────────┐
    │         │                 │
┌───▼───┐ ┌──▼────┐    ┌────────▼────────┐
│tenant │ │RabbitMQ│    │   MongoDB       │
│  API  │ │Queues  │    │   (Models)      │
│ (REST)│ │        │    │                 │
└───────┘ └────────┘    └─────────────────┘
```

### Потоки данных

1. **Чтение данных (диалоги, сообщения)**
   - gRPC Client → gRPC Server → tenant-api (REST) → MongoDB
   - gRPC Server → gRPC Client (ответ)

2. **Запись данных (отправка сообщений)**
   - gRPC Client → gRPC Server → tenant-api (REST) → MongoDB + Events
   - tenant-api → RabbitMQ (event) → Update Worker → RabbitMQ (update)
   - RabbitMQ → gRPC Server → gRPC Client (stream update)

3. **Получение updates в реальном времени**
   - Update Worker → RabbitMQ (update.*.{userType}.{userId}.*)
   - gRPC Server (подписка на очередь пользователя) → gRPC Client (stream)

## Функциональность

### 1. Получение диалогов пользователя

**gRPC метод:** `GetUserDialogs`

**Эквивалент REST:** `GET /api/users/:userId/dialogs`

**Параметры:**
- `userId` (string) - идентификатор пользователя
- `page` (int32) - номер страницы (по умолчанию 1)
- `limit` (int32) - количество элементов (по умолчанию 10)
- `filter` (string) - фильтр в формате операторов `(field,operator,value)`
- `sort` (string) - сортировка в формате JSON
- `includeLastMessage` (bool) - включить последнее сообщение

**Особенности:**
- Пагинация через `page` и `limit`
- Поддержка фильтрации по meta тегам
- Возможность включить последнее сообщение для каждого диалога
- Сортировка по `lastInteractionAt` по умолчанию

**Вопросы:**
1. Нужна ли поддержка курсорной пагинации вместо страничной для gRPC?
2. Как обрабатывать фильтры в proto? Использовать строковый формат или структурированные поля?
3. Нужна ли поддержка streaming для больших списков диалогов?

### 2. Получение сообщений диалога

**gRPC метод:** `GetDialogMessages`

**Эквивалент REST:** `GET /api/users/:userId/dialogs/:dialogId/messages`

**Параметры:**
- `userId` (string) - идентификатор пользователя
- `dialogId` (string) - идентификатор диалога
- `page` (int32) - номер страницы
- `limit` (int32) - количество сообщений
- `filter` (string) - фильтр
- `sort` (string) - сортировка

**Особенности:**
- Возвращает полную информацию о сообщении (statusMessageMatrix, reactionSet)
- Доступно только для участников диалога
- Сообщения обогащаются метаданными и статусами

**Вопросы:**
1. Стоит ли использовать streaming для получения сообщений (последние N сообщений + новые по stream)?
2. Как обрабатывать большие истории сообщений? Нужна ли поддержка получения с определенного timestamp?
3. Нужна ли поддержка получения сообщений по диапазону (fromMessageId, toMessageId)?

### 3. Отправка сообщений

**gRPC метод:** `SendMessage`

**Эквивалент REST:** `POST /api/dialogs/:dialogId/messages`

**Параметры:**
- `dialogId` (string) - идентификатор диалога
- `senderId` (string) - идентификатор отправителя
- `content` (string) - содержимое сообщения
- `type` (string) - тип сообщения (по умолчанию `internal.text`)
- `meta` (map<string, any>) - метаданные сообщения
- `idempotencyKey` (string, optional) - ключ идемпотентности

**Особенности:**
- Создает событие `message.create`
- Обновляет счетчики непрочитанных сообщений
- Генерирует Update для всех участников диалога
- Поддержка идемпотентности

**Вопросы:**
1. Нужен ли отдельный метод для отправки медиафайлов или использовать `type` и `meta`?
2. Как обрабатывать ошибки валидации? Использовать gRPC status codes или кастомные error details?
3. Нужна ли поддержка batch отправки сообщений (отправка нескольких сообщений за один запрос)?

### 4. Получение updates в реальном времени

**gRPC метод:** `SubscribeUpdates` (Server Streaming)

**Эквивалент:** Подписка на RabbitMQ очередь `user_{userId}_updates`

**Параметры:**
- `userId` (string) - идентификатор пользователя
- `filter` (UpdateFilter, optional) - фильтр по типам updates

**Типы updates:**
- `DialogUpdate` - обновления диалогов
- `DialogMemberUpdate` - обновления участников
- `MessageUpdate` - обновления сообщений
- `TypingUpdate` - индикаторы печати
- `UserUpdate` - обновления пользователя
- `UserStatsUpdate` - обновления статистики

**Особенности:**
- Server streaming RPC
- Автоматическая подписка на RabbitMQ очередь пользователя
- Routing key: `update.*.{userType}.{userId}.*`
- TTL очереди: 1 час

**Вопросы:**
1. Как обрабатывать переподключение клиента? Нужна ли поддержка resume с lastUpdateId?
2. Что делать с updates, которые были пропущены во время отключения? Нужна ли синхронизация через API?
3. Нужна ли поддержка фильтрации updates на стороне сервера (например, только MessageUpdate)?
4. Как обрабатывать heartbeat/ping для проверки соединения? Использовать отдельный метод или встроить в stream?
5. Что делать с обновлениями, которые не были обработаны клиентом? Нужен ли механизм подтверждения (ack)?

## Аутентификация и авторизация

### Текущая система (tenant-api)

- **API ключи** (`X-API-Key`) - глобальные или привязанные к тенанту
- **Tenant ID** (`X-Tenant-ID`) - изоляция данных по тенантам
- **Пользователь** определяется из параметров запроса (URL path)

### Варианты для gRPC

#### Вариант 1: API ключи в метаданных
```
Metadata:
  x-api-key: "api-key-here"
  x-tenant-id: "tnt_default"
  x-user-id: "user_123"  // Для определения пользователя
```

**Плюсы:**
- Соответствует текущей архитектуре
- Простая реализация
- Централизованное управление через ApiKey модель

**Минусы:**
- Неудобно для мобильных клиентов (нужно хранить API ключ)
- Нет индивидуальной аутентификации пользователей

#### Вариант 2: Токены пользователей
```
Metadata:
  authorization: "Bearer user-token-here"
```

**Плюсы:**
- Удобнее для мобильных приложений
- Можно выдавать персональные токены пользователям
- Лучшая изоляция между пользователями

**Минусы:**
- Требуется создание системы токенов
- Нужна модель UserToken или расширение ApiKey модели

#### Вариант 3: Гибридный подход
- API ключи для сервер-сервер интеграций
- Пользовательские токены для клиентских приложений

**Вопросы:**
1. Какой подход использовать для аутентификации?
2. Нужна ли поддержка OAuth2/JWT токенов?
3. Как обрабатывать refresh токенов?
4. Нужна ли поддержка сессий или stateless аутентификация?

## Мультитенантность

### Текущая реализация

- Tenant ID передается через заголовок `X-Tenant-ID`
- По умолчанию используется `tnt_default`
- Все данные изолированы по тенантам

### Для gRPC

**Вариант 1:** Tenant ID в метаданных запроса (как сейчас в REST)

**Вариант 2:** Tenant ID определяется из контекста пользователя (User модель содержит tenantId)

**Вопросы:**
1. Нужна ли поддержка одного пользователя в нескольких тенантах?
2. Должен ли tenant ID быть явным в каждом запросе или определяться автоматически?
3. Как обрабатывать случаи, когда пользователь не существует в указанном тенанте?

## Протокол определения (Proto)

### Структура сервиса

```protobuf
service Chat3UserService {
  // Получение диалогов
  rpc GetUserDialogs(GetUserDialogsRequest) returns (GetUserDialogsResponse);
  
  // Получение сообщений
  rpc GetDialogMessages(GetDialogMessagesRequest) returns (GetDialogMessagesResponse);
  
  // Отправка сообщения
  rpc SendMessage(SendMessageRequest) returns (SendMessageResponse);
  
  // Подписка на обновления (streaming)
  rpc SubscribeUpdates(SubscribeUpdatesRequest) returns (stream Update);
  
  // Отправка индикатора печати
  rpc SendTypingIndicator(SendTypingIndicatorRequest) returns (SendTypingIndicatorResponse);
  
  // Установка статуса сообщения
  rpc SetMessageStatus(SetMessageStatusRequest) returns (SetMessageStatusResponse);
  
  // Реакции на сообщения
  rpc SetMessageReaction(SetMessageReactionRequest) returns (SetMessageReactionResponse);
}
```

### Вопросы по proto дизайну

1. **Типы данных:**
   - Как обрабатывать timestamps? Использовать `google.protobuf.Timestamp` или `double` (микросекунды)?
   - Как обрабатывать meta теги? Использовать `google.protobuf.Struct` или `map<string, string>`?
   - Как обрабатывать вложенные объекты (например, `senderInfo`, `statusMessageMatrix`)?

2. **Опциональные поля:**
   - Какие поля должны быть optional vs required?
   - Нужна ли поддержка `oneof` для различных типов updates?

3. **Версионирование:**
   - Нужна ли поддержка версионирования proto? Как обрабатывать backward compatibility?

4. **Ошибки:**
   - Использовать стандартные gRPC status codes или кастомные?
   - Нужна ли детализация ошибок через `google.rpc.ErrorInfo`?

## Интеграция с tenant-api

### Подход 1: HTTP клиент внутри gRPC сервера

**Реализация:**
- gRPC сервер делает HTTP запросы к tenant-api
- Использование существующих контроллеров и валидации

**Плюсы:**
- Минимальные изменения в tenant-api
- Переиспользование логики
- Простая отладка

**Минусы:**
- Overhead на сериализацию/десериализацию
- Дополнительный сетевой хоп

### Подход 2: Прямой доступ к моделям

**Реализация:**
- gRPC сервер использует те же модели и утилиты
- Вызов логики контроллеров напрямую (без HTTP)

**Плюсы:**
- Меньше overhead
- Прямой доступ к данным

**Минусы:**
- Дублирование логики валидации
- Требуется рефакторинг контроллеров

### Подход 3: Shared service layer

**Реализация:**
- Выделение общей бизнес-логики в сервисный слой
- Использование в REST контроллерах и gRPC handlers

**Плюсы:**
- DRY принцип
- Единая точка логики
- Легче тестировать

**Минусы:**
- Требуется рефакторинг существующего кода

**Вопросы:**
1. Какой подход предпочтительнее?
2. Нужна ли поддержка параллельной работы REST и gRPC интерфейсов?
3. Как обрабатывать различия в форматах ответов (REST JSON vs gRPC proto)?

## Интеграция с RabbitMQ

### Подписка на updates

**Механизм:**
1. При подключении клиента создается подписка на очередь `user_{userId}_updates`
2. Определяется тип пользователя из User модели
3. Очередь привязывается к exchange `chat3_updates` с routing key `update.*.{userType}.{userId}.*`
4. Updates из очереди транслируются в gRPC stream

**Вопросы:**
1. Создавать ли очередь при каждом подключении или переиспользовать существующую?
2. Как обрабатывать несколько подключений одного пользователя? Распределять updates между соединениями?
3. Нужна ли поддержка QoS/prefetch для RabbitMQ (сколько сообщений держать в буфере)?
4. Что делать с updates, которые не могут быть доставлены клиенту (буфер переполнен, клиент отключен)?

### Управление соединениями

**Вопросы:**
1. Нужна ли поддержка graceful shutdown (завершение обработки текущих updates перед отключением)?
2. Как обрабатывать длительные отключения? Сохранять updates в MongoDB или терять их?
3. Нужен ли механизм heartbeat между gRPC сервером и RabbitMQ?

## Обработка ошибок

### Сценарии ошибок

1. **Пользователь не найден**
   - gRPC Status: `NOT_FOUND`
   - Error details: `UserNotFound`

2. **Диалог не найден**
   - gRPC Status: `NOT_FOUND`
   - Error details: `DialogNotFound`

3. **Пользователь не участник диалога**
   - gRPC Status: `PERMISSION_DENIED`
   - Error details: `NotDialogMember`

4. **Ошибка валидации**
   - gRPC Status: `INVALID_ARGUMENT`
   - Error details: `ValidationError` с описанием полей

5. **Ошибка RabbitMQ**
   - gRPC Status: `UNAVAILABLE`
   - Error details: `RabbitMQConnectionError`

**Вопросы:**
1. Нужна ли детализация ошибок через `google.rpc.ErrorInfo`?
2. Как обрабатывать бизнес-логические ошибки (например, попытка отправить сообщение в архивный диалог)?
3. Нужна ли поддержка retry механизма на клиенте?

## Производительность и масштабирование

### Кэширование

**Вопросы:**
1. Нужен ли кэш для данных пользователя (диалоги, сообщения)?
2. Как обрабатывать инвалидацию кэша при получении updates?
3. Использовать ли Redis для кэширования?

### Масштабирование

**Вопросы:**
1. Как распределять gRPC серверы? Нужна ли поддержка load balancing?
2. Как обрабатывать sticky sessions для streaming соединений?
3. Нужна ли поддержка горизонтального масштабирования RabbitMQ очередей?

### Метрики и мониторинг

**Вопросы:**
1. Какие метрики отслеживать? (количество подключений, latency, throughput)
2. Нужна ли поддержка distributed tracing (OpenTelemetry)?
3. Как логировать gRPC запросы? Нужен ли отдельный журнал или использовать существующий ApiJournal?

## Безопасность

### Вопросы

1. **TLS/SSL:**
   - Обязателен ли TLS для gRPC соединений?
   - Как управлять сертификатами?

2. **Rate limiting:**
   - Нужно ли ограничивать количество запросов от одного пользователя?
   - Как обрабатывать DDoS атаки?

3. **Валидация данных:**
   - Использовать ли proto валидацию или дублировать валидацию из tenant-api?
   - Как обрабатывать injection атаки?

4. **Авторизация:**
   - Нужна ли проверка прав доступа на уровне gRPC (например, пользователь может получать только свои диалоги)?
   - Как обрабатывать права доступа для разных типов пользователей (user, bot, agent)?

## Идемпотентность

### Текущая реализация (REST)

- Поддержка через заголовок `X-Idempotency-Key`
- Сохранение результатов запросов

### Для gRPC

**Вопросы:**
1. Передавать ли idempotency key через метаданные?
2. Нужна ли поддержка идемпотентности для всех методов или только для мутаций?
3. Как обрабатывать дубликаты запросов при переподключении?

## Тестирование

### Вопросы

1. Как тестировать gRPC сервис? Использовать существующую тестовую инфраструктуру (mongodb-memory-server, fake-amqplib)?
2. Нужны ли интеграционные тесты с реальным RabbitMQ?
3. Как мокировать tenant-api для unit тестов?

## Документация

### Вопросы

1. Нужна ли автогенерация документации из proto файлов?
2. Как документировать ошибки и их обработку?
3. Нужны ли примеры использования для разных языков (TypeScript, Go, Python)?

## Следующие шаги

1. **Определить подход к аутентификации** - API ключи vs токены пользователей
2. **Спроектировать proto файлы** - определить структуры сообщений и сервисы
3. **Выбрать подход к интеграции** - HTTP клиент vs прямой доступ к моделям vs service layer
4. **Реализовать прототип** - базовый gRPC сервер с одним методом (например, GetUserDialogs)
5. **Интегрировать RabbitMQ** - реализовать SubscribeUpdates streaming
6. **Добавить обработку ошибок** - определить стратегию и реализовать
7. **Написать тесты** - unit и интеграционные тесты
8. **Документировать API** - создать документацию и примеры

## Уточнения для реализации (решения)

### Принятые решения

1. ✅ **Аутентификация:** Используем API ключ через метаданные gRPC (`x-api-key`)
2. ✅ **Интеграция с tenant-api:** HTTP клиент (axios), без прямого доступа к MongoDB моделям
3. ✅ **Обработка updates:** 
   - Переподключение - просто переподключаться
   - RabbitMQ очереди с TTL 1 час (updates будут ждать в очереди при кратковременном отключении)
   - Если один пользователь подключен дважды - дублировать все updates в оба соединения
4. ✅ **Кэширование:** Не нужен на данном этапе
5. ✅ **Timestamps:** Использовать `double` (микросекунды) для максимальной точности
6. ✅ **Конфигурация:** Задается через переменные окружения
7. ✅ **userType:** Получаем через HTTP запрос к `GET /api/users/:userId` из tenant-api
8. ✅ **Tenant ID и User ID:** Передавать в метаданных gRPC (`x-tenant-id`, `x-user-id`)
9. ✅ **RabbitMQ:** Отдельное подключение в gRPC сервере (не использовать @chat3/utils)
10. ✅ **Структура проекта:** Создать два новых пакета:
    - `packages/user-grpc-server/` - gRPC сервер
    - `packages/user-grpc-client-ts/` - TypeScript клиент для gRPC
11. ✅ **Изоляция:** Новые пакеты не должны вносить изменения в существующие пакеты
12. ✅ **Порт:** По умолчанию 50051
13. ✅ **Meta теги:** Использовать `google.protobuf.Struct` для гибкости (поддержка любых типов)
14. ✅ **Генерация TypeScript типов:** Автоматическая генерация (предпочтительно)
15. ✅ **Обработка ошибок:** Все ошибки логируются в `console.log`, должны быть понятными
16. ✅ **Connection ID:** Использовать connId в имени очереди для уникальности каждого соединения

## Оставшиеся вопросы

### 1. Конфигурация (переменные окружения)

**Вопросы:**
1. **Порт для gRPC сервера?**
   - Какой порт использовать по умолчанию? (например, 50051)

2. **Переменные окружения для gRPC сервера:**
   - `TENANT_API_URL` - базовый URL tenant-api (например, `http://localhost:3000`)
   - `RABBITMQ_URL` - URL для RabbitMQ (например, `amqp://localhost:5672`)
   - `GRPC_PORT` - порт для gRPC сервера (по умолчанию 50051)
   - Нужны ли другие? (например, `GRPC_HOST`, `LOG_LEVEL`)

### 2. Proto структура

**Вопросы:**
1. **Meta теги:**
   - Использовать `google.protobuf.Struct` (поддерживает любые типы) или `map<string, string>`?
   - Meta теги могут содержать разные типы данных (string, number, boolean, object, array)
   - Рекомендация: `google.protobuf.Struct` для гибкости

2. **Структура сообщений:**
   - Как организовать вложенные объекты (например, `senderInfo`, `statusMessageMatrix`)?
   - Создавать отдельные message типы для каждого вложенного объекта?

### 3. Минимальный набор методов (MVP)

**Вопросы:**
1. **Основные методы для MVP:**
   - `GetUserDialogs` - получение диалогов пользователя
   - `GetDialogMessages` - получение сообщений диалога
   - `SendMessage` - отправка сообщения
   - `SubscribeUpdates` - подписка на updates (streaming)
   
   **Дополнительные методы (пока не включены):**
   - `SetMessageStatus` - установка статуса сообщения
   - `SetMessageReaction` - реакции на сообщения
   - `SendTypingIndicator` - индикатор печати
   
   Подтверждаем этот набор для MVP?

### 4. Обработка ошибок

**Вопросы:**
1. **Стратегия обработки ошибок:**
   - Использовать стандартные gRPC status codes (NOT_FOUND, PERMISSION_DENIED, INVALID_ARGUMENT, etc.)?
   - Нужна ли детализация через `google.rpc.ErrorInfo` или достаточно стандартных кодов?

2. **Маппинг HTTP статусов в gRPC:**
   - 401 → UNAUTHENTICATED
   - 403 → PERMISSION_DENIED
   - 404 → NOT_FOUND
   - 400 → INVALID_ARGUMENT
   - 500 → INTERNAL
   - Подтверждаем такой маппинг?

### 5. RabbitMQ интеграция и Connection ID

**Решение:** Использовать connId в имени очереди для уникальности каждого соединения

**Варианты организации очередей:**

#### Вариант A: Одна очередь на пользователя (не подходит для дублирования)
- **Имя очереди:** `user_{userId}_updates`
- **Проблема:** При нескольких подключениях одного пользователя сообщения будут удаляться из очереди после обработки одним клиентом
- **Не подходит** для требования дублирования updates

#### Вариант B: Отдельная очередь на каждое соединение (с connId) ⭐ **Рекомендуется**
- **Имя очереди:** `user_{userId}_conn_{connId}_updates`
- **Преимущества:**
  - Каждое соединение получает свою очередь
  - Все очереди одного пользователя подписываются на один routing key: `update.*.{userType}.{userId}.*`
  - RabbitMQ автоматически дублирует сообщения для каждой очереди (fan-out)
  - TTL 1 час для каждой очереди (автоматическая очистка при отключении)
  - Не нужно явно удалять очереди при отключении

**Принятые решения:**
1. ✅ **Формат connId:** `conn_` + 5 символов (a-z0-9) - например, `conn_abc12`
2. ✅ **Где генерировать:** На сервере при установлении соединения `SubscribeUpdates`
3. ✅ **Передача connId клиенту:** Возвращать в `SubscribeUpdatesResponse` для отладки
4. ✅ **Хранение связи:** Не требуется, userId извлекается из метаданных подключения
5. ✅ **Очистка очередей:** Полагаться на TTL 1 час (автоматическая очистка)

### 6. Зависимости

**Вопросы:**
1. **gRPC библиотеки:**
   - Использовать `@grpc/grpc-js` для сервера?
   - Использовать `@grpc/proto-loader` для загрузки proto файлов?
   - Подтверждаем эти библиотеки?
   - **Рекомендация:** Да, стандартный набор для Node.js

2. **HTTP клиент:**
   - Использовать `axios` (как в tenant-api-client)?
   - Подтверждаем `axios`?
   - **Рекомендация:** Да, для консистентности

3. **RabbitMQ библиотека:**
   - Использовать `amqplib` (как в существующих пакетах)?
   - Подтверждаем `amqplib`?
   - **Рекомендация:** Да, для консистентности

### 7. Генерация TypeScript типов из proto

**Вопросы:**
**Принятое решение:**
1. ✅ **Автогенерация типов:** Использовать `protoc` + `ts-proto` - генерирует чистые TypeScript типы
2. ✅ **Инструменты:**
   - `protoc` (Protocol Buffers compiler)
   - `ts-proto` (плагин для protoc)
   - Скрипт `generate:proto` в `package.json` для автоматической генерации

### 8. Структура пакетов

**Вопросы:**
1. **Размещение proto файлов:**
   - В `packages/user-grpc-server/proto/`?
   - Или в отдельной директории, доступной обоим пакетам?

2. **Экспорт proto из сервера:**
   - Должен ли `user-grpc-server` экспортировать proto файлы?
   - Или `user-grpc-client-ts` должен иметь свою копию proto?

## Структура новых пакетов

### 1. `packages/user-grpc-server/`

**Назначение:** gRPC сервер для пользователей

**Структура:**
```
packages/user-grpc-server/
├── proto/                      # Proto файлы
│   └── chat3_user.proto
├── src/
│   ├── config/                 # Конфигурация
│   │   └── index.ts
│   ├── handlers/               # gRPC handlers
│   │   ├── getUserDialogs.ts
│   │   ├── getDialogMessages.ts
│   │   ├── sendMessage.ts
│   │   └── subscribeUpdates.ts
│   ├── services/               # Бизнес-логика
│   │   ├── tenantApiClient.ts  # HTTP клиент для tenant-api
│   │   └── rabbitmqClient.ts   # RabbitMQ клиент
│   ├── utils/                  # Утилиты
│   │   └── errorMapper.ts      # Маппинг HTTP ошибок в gRPC
│   └── index.ts                # Точка входа
├── package.json
└── tsconfig.json
```

**Зависимости:**
- `@grpc/grpc-js` - gRPC сервер
- `@grpc/proto-loader` - загрузка proto файлов
- `axios` - HTTP клиент для tenant-api
- `amqplib` - RabbitMQ клиент

**Переменные окружения:**
- `TENANT_API_URL` - URL tenant-api (например, `http://localhost:3000`)
- `RABBITMQ_URL` - URL RabbitMQ (например, `amqp://localhost:5672`)
- `GRPC_PORT` - порт gRPC сервера (по умолчанию `50051`)
- `GRPC_HOST` - хост gRPC сервера (по умолчанию `0.0.0.0`)
- `LOG_LEVEL` - уровень логирования (по умолчанию `info`)

### 2. `packages/user-grpc-client-ts/`

**Назначение:** TypeScript клиент для gRPC сервера

**Структура:**
```
packages/user-grpc-client-ts/
├── proto/                      # Proto файлы (копия из сервера)
│   └── chat3_user.proto
├── src/
│   ├── Chat3GrpcClient.ts      # Основной клиент
│   ├── types.ts                # TypeScript типы (сгенерированные из proto)
│   └── index.ts                # Экспорты
├── package.json
└── tsconfig.json
```

**Зависимости:**
- `@grpc/grpc-js` - gRPC клиент
- `@grpc/proto-loader` - загрузка proto файлов

**Использование:**
```typescript
import { Chat3GrpcClient } from '@chat3/user-grpc-client-ts';

const client = new Chat3GrpcClient({
  url: 'localhost:50051',
  apiKey: 'your-api-key',
  tenantId: 'tnt_default',
  userId: 'user_123'
});

const dialogs = await client.getUserDialogs({ page: 1, limit: 10 });
const stream = client.subscribeUpdates();
```

## План реализации

### Этап 1: Настройка структуры проекта

**Задачи:**
1. ✅ Создать `packages/user-grpc-server/`
   - Создать структуру директорий
   - Настроить `package.json` с зависимостями
   - Настроить `tsconfig.json`
   - Добавить скрипты `build`, `start`, `dev`

2. ✅ Создать `packages/user-grpc-client-ts/`
   - Создать структуру директорий
   - Настроить `package.json` с зависимостями
   - Настроить `tsconfig.json`

3. ✅ Обновить корневой `package.json`
   - Добавить скрипты для запуска gRPC сервера
   - Обновить `start:all` если нужно

### Этап 2: Определение Proto файлов

**Задачи:**
1. ✅ Создать `proto/chat3_user.proto`
   - Определить сервис `Chat3UserService`
   - Определить сообщения для всех методов MVP:
     - `GetUserDialogsRequest/Response`
     - `GetDialogMessagesRequest/Response`
     - `SendMessageRequest/Response`
     - `SubscribeUpdatesRequest/SubscribeUpdatesResponse/Update`
     - В `SubscribeUpdatesResponse` добавить поле `connId` (string)
   - Использовать `double` для timestamps
   - Использовать `google.protobuf.Struct` для meta тегов

2. ✅ Скопировать proto в `user-grpc-client-ts/proto/`

### Этап 3: Базовая инфраструктура сервера

**Задачи:**
1. ✅ Создать `src/config/index.ts`
   - Чтение переменных окружения
   - Валидация конфигурации

2. ✅ Создать `src/services/tenantApiClient.ts`
   - HTTP клиент на основе axios
   - Методы для вызова tenant-api endpoints
   - Передача `X-API-Key` и `X-Tenant-ID` заголовков

3. ✅ Создать `src/utils/errorMapper.ts`
   - Маппинг HTTP статусов в gRPC status codes
   - Обработка ошибок валидации
   - Логирование всех ошибок в `console.log` с понятными сообщениями

4. ✅ Создать `src/utils/connectionId.ts`
   - Функция генерации connId: `conn_` + 5 символов (a-z0-9)
   - Функция форматирования имени очереди: `user_{userId}_conn_{connId}_updates`

### Этап 4: Реализация handlers (MVP методы)

**Задачи:**
1. ✅ `GetUserDialogs` handler
   - Извлечение `userId` и `tenantId` из метаданных
   - Вызов tenant-api `GET /api/users/:userId/dialogs`
   - Маппинг ответа в gRPC формат
   - Обработка ошибок

2. ✅ `GetDialogMessages` handler
   - Извлечение параметров из запроса
   - Вызов tenant-api `GET /api/users/:userId/dialogs/:dialogId/messages`
   - Маппинг ответа в gRPC формат

3. ✅ `SendMessage` handler
   - Валидация параметров
   - Вызов tenant-api `POST /api/dialogs/:dialogId/messages`
   - Маппинг ответа в gRPC формат

### Этап 5: RabbitMQ интеграция для Updates

**Задачи:**
1. ✅ Создать `src/services/rabbitmqClient.ts`
   - Подключение к RabbitMQ
   - Создание/проверка очереди `user_{userId}_updates`
   - Подписка на exchange `chat3_updates` с routing key `update.*.{userType}.{userId}.*`
   - Получение `userType` через HTTP запрос к tenant-api

2. ✅ Реализовать `SubscribeUpdates` handler (server streaming)
   - Генерация connId при подключении (формат: `conn_` + 5 символов)
   - Возврат connId в `SubscribeUpdatesResponse` для отладки
   - Создание очереди `user_{userId}_conn_{connId}_updates` для соединения (TTL 1 час)
   - Получение userType через HTTP запрос к tenant-api `GET /api/users/:userId`
   - Подписка на exchange `chat3_updates` с routing key `update.*.{userType}.{userId}.*`
   - Трансляция updates из RabbitMQ в gRPC stream
   - Обработка отключений клиента (graceful shutdown, TTL очистит очередь автоматически)
   - Поддержка нескольких подключений одного пользователя (каждое соединение - своя очередь, дублирование автоматически)

### Этап 6: Основной файл сервера

**Задачи:**
1. ✅ Создать `src/index.ts`
   - Инициализация gRPC сервера
   - Загрузка proto файлов
   - Регистрация handlers
   - Запуск сервера
   - Graceful shutdown

### Этап 7: TypeScript клиент (базовая версия)

**Задачи:**
1. ✅ Создать `src/Chat3GrpcClient.ts`
   - Инициализация gRPC клиента
   - Методы для вызова всех MVP методов
   - Работа с метаданными (apiKey, tenantId, userId)
   - Обработка streaming для `SubscribeUpdates`

2. ✅ Генерация TypeScript типов из proto
   - Настроить `ts-proto` для генерации типов
   - Добавить скрипт `generate:proto` в package.json
   - Типы будут автоматически сгенерированы из proto файлов
   - Использовать `protoc` + `ts-proto` плагин

### Этап 8: Тестирование

**Задачи:**
1. ✅ Интеграционные тесты
   - Подключение к реальному tenant-api
   - Подключение к реальному RabbitMQ
   - Проверка всех MVP методов

2. ✅ Проверка работы с несколькими подключениями

### Этап 9: Документация

**Задачи:**
1. ✅ README для `user-grpc-server`
   - Описание конфигурации
   - Примеры использования

2. ✅ README для `user-grpc-client-ts`
   - Установка и использование
   - Примеры кода

## Порядок выполнения

**Рекомендуемый порядок:**
1. Этап 1: Настройка структуры
2. Этап 2: Proto файлы (определение интерфейса)
3. Этап 3: Базовая инфраструктура
4. Этап 4: Handlers (кроме SubscribeUpdates)
5. Этап 6: Основной файл сервера (для тестирования первых методов)
6. Этап 5: RabbitMQ интеграция
7. Этап 4 (продолжение): SubscribeUpdates handler
8. Этап 7: TypeScript клиент
9. Этап 8-9: Тестирование и документация

## Критерии готовности MVP

✅ Сервер запускается и принимает соединения
✅ Все 4 MVP метода работают
✅ Updates транслируются через streaming
✅ Поддерживается несколько подключений одного пользователя (каждое соединение - своя очередь с connId)
✅ Ошибки корректно маппятся в gRPC статусы и логируются в console.log
✅ TypeScript клиент может подключиться и использовать все методы
✅ TypeScript типы генерируются автоматически из proto файлов

## Резюме решений по connectionId

### Принятый подход: Отдельная очередь на каждое соединение

**Формат имени очереди:** `user_{userId}_conn_{connId}_updates`

**Где:**
- `userId` - идентификатор пользователя (из метаданных gRPC)
- `connId` - уникальный идентификатор соединения, генерируется на сервере
- Формат connId: `conn_` + 5 символов (a-z0-9) - например, `conn_abc12`

**Преимущества:**
1. Каждое соединение изолировано (своя очередь)
2. RabbitMQ автоматически дублирует updates для всех очередей одного пользователя
3. TTL 1 час автоматически очищает очереди при отключении
4. Не нужно явно отслеживать активные соединения
5. Соответствует паттернам проекта (формат ID как dlg_, msg_, topic_)

**Финальные решения:**
1. ✅ Формат connId: `conn_` + 5 символов (a-z0-9) - например, `conn_abc12`
2. ✅ Возвращать connId в `SubscribeUpdatesResponse` для отладки
3. ✅ Полагаться на TTL RabbitMQ (явное удаление не требуется)
4. ✅ Использовать `ts-proto` для генерации TypeScript типов